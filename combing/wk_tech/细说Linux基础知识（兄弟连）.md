细说Linux基础知识（兄弟连）




# 细说Linux基础知识（兄弟连）

--------------------------------------------------

## 目录

* [第1章 知其然而后知其所以然 Linux系统简介](#1)
	* [1.1 什么是操作系统](#1_1)
	* [1.2 从UNIX到Linux ](#1_2)
		* [1.2.1 UNIX的坎坷历史](#1_2_1)
		* [1.2.2 Linux的那些往事](#1_2_2)
		* [1.2.3 UNIX与Linux的亲密关系](#1_2_3)
		* [1.2.4 UNIX/Linux系统结构](#1_2_4)
		
	* [1.3 详细了解Linux](#1_3)
	* [1.4 学习Linux的建议](#1_4)
	
* [第2章 不识庐山真面目， 只缘身在此山中 Linux系统安装](#2)
	* [2.1 虚拟机软件VMware应用](#2_1)
	* [2.2 Linux光盘安装及设置](#2_2)
		* [2.2.1 CentOS6.x版本区别](#2_2_1)
		* [2.2.2 光盘安装CentOS6.x](#2_2_2)
	* [2.3 Linux U盘安装](#2_3)
		* [2.3.1 所需工具](#2_3_1)
		* [2.3.2 安装步骤](#2_3_2)
	* [2.4 Linux无人值守安装](#2_4)
		* [2.4.1 概念和原理](#2_4_1)
		* [2.4.2 无人值守安装的条件](#2_4_2)
		* [2.4.3 无人值守安装的步骤](#2_4_3)
	* [2.5 dd命令复制安装Linux](#2_5)
		* [2.5.1 dd命令是什么](#2_5_1)
		* [2.5.2 dd配置步骤](#2_5_2)
	* [2.6 远程管理工具](#2_6)
		* [2.6.1 短小精悍的PuTT](#2_6_1)
		* [2.6.2 功能强大的SecureCRT](#2_6_2)
		
* [第3章 葵花宝典:给初学者的Linux服务器管理建议](#3)
	* [3.1 学习Linux的注意事项](#3_1)
	* [3.2 Linux服务器的管理和维护建议](#3_2)
	
* [第4章 万丈高楼平地起：Linux常用命令](#4)
	* [4.1 命令的基本格式](#4_1)
	* [4.2 目录操作命令](#4_2)
	* [4.3 文件操作命令](#4_3)
	* [4.4 目录和文件都能操作的命令](#4_4)
	* [4.5 权限管理命令](#4_5)
	* [4.6 帮助命令](#4_6)
	* [4.7 搜索命令](#4_7)
	* [4.8 压缩和解压缩命令](#4_8)
	* [4.9 关机和重启命令](#4_9)
	* [4.10 常用网络命令](#4_10)

* [第5章 简约而不简单的文本编辑器Vim](#5)
	* [5.1 Vim的工作模式](#5_1)
	* [5.2 进入Vim](#5_2)
	* [5.3 Vim的基本应用](#5_3)
	* [5.4 Vim的进阶应用](#5_4 )
	
* [第6章 从小巧玲珑到羽翼渐丰:软件安装](#6)
	* [6.1 软件包管理简介](#6_1)
		* [6.1.1 软件包的分类](#6_1_1)
		* [6.1.2 初识源码包](#6_1_2)
		* [6.1.3 源码包的特点](#6_1_3)
		* [6.1.4 二进制包的特点](#6_1_4)
	* [6.2 RPM包管理----rpm命令管理](#6_2)
		* [6.2.1 RPM包的命令规则](#)
		* [6.2.2 RPM包的依赖性](#6_2_2)
		* [6.2.3 RPM包的安装与升级](#6_2_3)
		* [6.2.4 RPM包查询](#6_2_4)
		* [6.2.5 RPM包卸载](#6_2_5)
		* [6.2.6 RPM包校验与数字证书](#6_2_6)
		* [6.2.7 RPM包中的文件提取](#6_2_7)
		* [6.2.8 SRPM包的使用](#6_2_8)
		* [6.2.9 RPM包的深入应用](#6_2_9)
	* [6.3 RPM包管理--yum在线管理](#6_3)
		* [6.3.1 yum源搭建](#6_3_1)
		* [6.3.2 常用yum命令](#6_3_2)
		* [6.3.3 yum软件组管理](#6_3_3)
	* [6.4 源码包管理](#6_4)
		* [6.4.1 源码包的安装准备](#6_4_1)
		* [6.4.2 源码包安装](#6_4_2)
		* [6.4.3 源码包升级](#6_4_3)
		* [6.4.4 源码包卸载](#6_4_4)
		* [6.4.5 函数库管理](#6_4_5)
	* [6.5 脚本程序包管理](#6_5)
		* [6.5.1 脚本程序简介](#6_5_1)
		* [6.5.2 Webmin安装](#6_5_2)
	* [6.6 软件包的选择](#6_6)
	
* [第7章](#7)
	* [7.1 用户配置文件和管理相关文件](#7_1)
		* [7.1.1 用户信息文件/etc/passwd](#7_1_1)
		* [7.1.2 影子文件/etc/shadow](#7_1_2)
		* [7.1.3 组信息文件/etc/group](#7_1_3)
		* [7.1.4 组密码文件/etc/gshadow](#7_1_4)
		* [7.1.5 用户管理相关文件](#7_1_5)
	* [7.2 用户管理命令](#7_2)
		* [7.2.1 添加用户:useradd](#7_2_1)
		* [7.2.2 修改用户密码:passwd](#7_2_2)
		* [7.2.3 修改用户信息:usermod](#7_2_3)
		* [7.2.4 修改用户密码状态:chage](#7_2_4)
		* [7.2.5 删除用户:userdel](#7_2_5)
		* [7.2.6 查看用户的UID和GID:id](#7_2_6)
		* [7.2.7 切换用户身份:su](#7_2_7)
	* [7.3 用户组管理命令](#7_3)
		* [7.3.1 添加用户组:groupadd](#7_3_1)
		* [7.3.2 修改用户组:groupmod](#7_3_2)
		* [7.3.3 删除用户组:groupdel](#7_3_3)
		* [7.3.4 把用户添加进组或从组中删除:gpasswd](#7_3_4)
		* [7.3.5 改变有效组:newgrp](#7_3_5)
		
* [第8章 坚若磐石的防护之道:权限管理](#8)
	* [8.1 ACL权限](#8_1)
		* [8.1.1 开启ACL权限](#8_1_1)
		* [8.1.2 ACL权限设置](#8_1_2)
	* [8.2 文件特殊权限--SetUID SetGID StickyBIT](#8_2)
		* [8.2.1 文件特殊权限之 SetUID](#8_2_1)
		* [8.2.2 文件特殊权限之 SetGID](#8_2_2)
		* [8.2.3 文件特殊权限之 StickyBIT](#8_2_3)
		* [8.2.4 特殊权限设置](#8_2_4)
	* [8.3 文件系统属性chattr权限](#8_3)
		* [8.3.1 设定文件系统属性chattr](#8_3_1)
		* [8.3.1 查看文件系统属性lsattr](#8_3_2)
	* [8.4 系统命令sudo权限](#8_4)
		* [8.4.1 sudo用法](#8_4_1)
		* [8.4.2 sudo举例](#8_4_2)
		
* [第9章 牵一发而动全身:文件系统管理](#9)
	* [9.1 硬盘结构](#9_1)
		* [9.1.1 机械硬盘(HDD)](#9_1_1)
		* [9.1.2 固态硬盘(SSD)](#9_1_2)
	* [9.2 Linux中常见的文件系统](#9_2)
		* [9.2.1 文件系统的特性](#9_2_1)
		* [9.2.2 Linux支持的常见文件系统](#9_2_2)
	* [9.3 回顾硬盘分区](#9_3)
		* [9.3.1 硬盘分区的类型](#9_3_1)
		* [9.3.2 Linux中硬盘与分区的表示方式](#9_3_2)
	* [9.4 文件系统常用命令](#9_4)
		* [9.4.1 文件系统查看命令df](#9_4_1)
		* [9.4.2 统计目录或文件所占磁盘空间大小命令du](#9_4_2)
		* [9.4.3 挂载命令mount和卸载命令umount](#9_4_3)
		* [9.4.4 文件系统检测与修复命令fsck](#9_4_4)
		* [9.4.5 显示硬盘状态命令dumpe2fs](#9_4_5)
	* [9.5 fdisk命令分区](#9_5)
		* [9.5.1 添加新硬盘](#9_5_1)
		* [9.5.2 创建分区](#9_5_2)
		* [9.5.3 格式化分区](#9_5_3)
		* [9.5.4 建立挂载点并挂载](#9_5_4)
		* [9.5.5 实现开机后自动挂载](#9_5_5)
	* [9.6 /etc/fstab文件修复](#9_6)
	* [9.7 parted命令分区](#9_7)
		* [9.7.1 parted交互模式](#9_7_1)
		* [9.7.2 parted命令的使用](#9_7_2)
	* [9.8 分配swap分区](#9_8)
		* [9.8.1 分区](#9_8_1)
		* [9.8.2 格式化](#9_8_2)
		* [9.8.3 使用swap分区](#9_8_3)


>[返回目录](#目录)


--------------------------------------------------

## 1
## 知其然而后知其所以然： Linux系统简介

### 1_1
### 什么是操作系统   

### 1_2
### 从UNIX到Linux   

#### 1_2_1
#### UNIX的坎坷历史   

#### 1_2_2
#### Linux的那些往事    

#### 1_2_3
#### UNIX与Linux的亲密关系    

    二者的关系不是大哥与小弟,是父与子更恰当.   
    二者有两个大的区别:   
    其一，unix系统大多是与硬件配套，而Linux可以运行在多各硬件平台；
    其二，unix是商业软件，而linux是开源软件，是免费、公开源代码的。   

#### 1_2_4
#### UNIX/Linux系统结构  

### 1_3
### 详细了解Linux    

#### 1_3_1
#### 天使与魔鬼   

#### 1_3_2
#### Linux的应用领域 

#### 1_3_3
#### Linux的发行版本   

### 1_4
### 学习Linux的建议    




> [返回目录](#目录)
    
--------------------------------------------------

## 2
## 第2 章 不识庐山真面目， 只缘身在此山中： Linux系统安装
    
### 2_1
### 虚拟机软件VMware应用

### 2_2
### Linux光盘安装及设置

#### 2_2_1 
#### CentOS6.x版本区别

#### 2_2_2
#### 光盘安装CentOS6.x


### 2_3
### Linux U盘安装

#### 2_3_1
#### 所需工具

#### 2_3_2
#### 安装步骤

	
### 2_4
### Linux无人值守安装

#### 2_4_1
#### 概念和原理

#### 2_4_2
#### 无人值守安装的条件

#### 2_4_3
#### 无人值守安装的步骤

### 2_5	
### dd命令复制安装Linux

#### 2_5_1
#### dd命令是什么

#### 2_5_2
#### dd配置步骤

### 2_6	
### 远程管理工具

#### 2_6_1
#### 短小精悍的PuTTY

#### 2_6_2
#### 功能强大的SecureCRT

	

>[返回目录](#目录)


--------------------------------------------------

## 3
## 第3章 葵花宝典:给初学者的Linux服务器管理建议

### 3_1
### 学习Linux的注意事项

### 3_2
### Linux服务器的管理和维护建议


>[返回目录](#目录)


--------------------------------------------------
## 4
## 第4章 万丈高楼平地起：Linux常用命令

### 4_1
### 命令的基本格式
    4.1.1 命令提示符
    4.1.2 命令的基本格式


>[返回目录](#目录)

	
### 4_2
### 目录操作命令
    4.2.1 ls命令
    4.2.2 cd命令
    4.2.3 mkdir命令
    4.2.4 rmdir命令
    4.2.5 tree命令

### 4_3
### 文件操作命令
    4.3.1 touch命令
    4.3.2 stat命令
    4.3.3 cat命令
    4.3.4 more命令
    4.3.5 less命令
    4.3.6 head命令
    4.3.7 tail命令
    4.3.8 ln命令


>[返回目录](#目录)

	
### 4_4
### 目录和文件都能操作的命令
    4.4.1 rm命令
    4.4.2 cp命令
    4.4.3 mv命令

### 4_5
### 权限管理命令
    4.5.1 权限介绍
    4.5.2 基本权限的命令
    4.5.3 基本权限的含义
    4.5.4 所有者和所属组命令
    4.5.5 umask默认权限


>[返回目录](#目录)


### 4_6
### 帮助命令
    4.6.1 man命令
    4.6.2 info命令
    4.6.3 help命令
    4.6.4 --help选项


>[返回目录](#目录)

	
### 4_7
### 搜索命令
    4.7.1 whereis命令
    4.7.2 which命令
    4.7.3 locate命令
    4.7.4 find命令


>[返回目录](#目录)


### 4_8
### 压缩和解压缩命令
    4.8.1 压缩文件介绍
    4.8.2 ".zip"格式
    4.8.3 ".gz"格式
    4.8.4 ".bz2"格式
    4.8.5 ".tar"格式
    4.8.6 ".tar.gz"和".tar.bz2"格式


>[返回目录](#目录)


### 4_9
### 关机和重启命令
    4.9.1 sync数据同步
    4.9.2 shutdown命令
    4.9.3 reboot命令
    4.9.4 halt和poweroff命令
    4.9.5 init命令


>[返回目录](#目录)


### 4_10
###  常用网络命令
    4.10.1 配置Linux的IP地址
    4.10.2 ifconfig命令
    4.10.3 ifup和ifdown命令
    4.10.4 ping命令
    4.10.5 netstat命令
    4.10.6 write命令
    4.10.7 wall命令
    4.10.8 mail命令

>[返回目录](#目录)


--------------------------------------------------

## 5
## 第5章 简约而不简单的文本编辑器Vim
 
### 5_1
### Vim的工作模式

### 5_2
### 进入Vim
    5.2.1 使用vim打开文件
    5.2.2 直接进入指定位置
	
### 5_3
### Vim的基本应用
    5.3.1 插入命令
    5.3.2 光标移动命令
    5.3.3 使用Vim进行编辑
    5.3.4 保存退出命令
	
### 5_4
### Vim的进阶应用
    5.4.1 Vim配置文件
    5.4.2 多窗口编辑
    5.4.3 区域复制
    5.4.4 定义快捷
    5.4.5 在Vim中与Shell交互
    5.4.6 文本格式转换
    5.4.7 Vim的宏记录
    5.4.8 ab命令的小技巧


>[返回目录](#目录)

--------------------------------------------------

## 6
## 第6章 从小巧玲珑到羽翼渐丰:软件安装

### 6_1
### 软件包管理简介

#### 6_1_1
#### 软件包的分类
        源码包  二进制包

#### 6_1_2
#### 初识源码包

#### 6_1_3
#### 源码包的特点
        源代码文件
        配置和检测程序(如configure或config等)
        软件安装说明和软件说明(如INSTALL或README)。

#### 6_1_4
#### 二进制包的特点

            目前两大主流的二包系统是DPKG包和RPM包。
            DPKG包是由Debian Linux所开发的包管理机制，通过DPKG包，Debian Linux
        就可以进行软件包管理,主要应用 有Debian和Ubuntu中。
            RPM包是由Red Hat公司所开发的包管理系统，功能强大，安装升级、查询和
        卸载都非常简单和方便.目前很多Linux版本都在使用这种包管理方式，包括
        Fedora CentOS SuSE等。


>[返回目录](#目录)


### 6_2
### RPM包管理----rpm命令管理

#### 6_2_1
#### RPM包的命令规则

        httpd-2.2.15-15.el6.centos.1.i686.rpm
        软件包名-软件版本-软件发布的次数-软件发行商-适合的硬件平台-RPM包的扩展名

#### 6_2_2
#### RPM包的依赖性
        www.rpmfind.net


>[返回目录](#目录)


#### 6_2_3
#### RPM包的安装与升级

        RPM包默认安装路径
            /etc/           配置文件安装目录
            /usr/bin/       可执行的命令安装目录
            /usr/lib/       程序所使用的函数库保存位置
            /usr/share/doc/ 基本的软件使用手册保存位置
            /usr/share/man/ 帮助文件保存位置
            
        rpm -ivh 包全名
            -i:安装（install)
            -v:显示更详细的信息（verbose)
            -h:打印#，显示安装进度（hash)
   
            --nodeps: 不检测依赖性安装
            --replacefiles:替换文件安装
            --replacepkgs:替换软件包安装
            --force:强制安装
            --test:测试安装。不实际安装，只是检测一下依赖性。
            --prefix：指定安装路径。
    
        rpm -Uvh 包全名   #RPM包的升级
        选项:
            -U(大写） 升级安装，如果没有安装过，则系统直接安装。否则升级到新版 
    
        eg: rom -ivh a.rpm b.rpm c.rpm


>[返回目录](#目录)


#### 6_2_4
#### RPM包查询

        rpm 选项 查询对象
        rpm -q 包名
        rpm -qa
        rpm -qi 包名
        rpm -qip 包全名
        rpm -ql 包名
        rpm -qlp 包全名
        rpm -qf 系统文件名
        rpm -qR 包名

#### 6_2_5
#### RPM包卸载

        rpm -e 包名


>[返回目录](#目录)


#### 6_2_6
#### RPM包校验与数字证书

        rpm -Va  #校验本机已经安装的所有软件包
        rpm -V 已安装的包名 #校验指定RPM包中的文件（verify)
        rpm -Vf 系统文件名
   
        rpm -V httpd
        没有任何提示信息说明没做过任何修改
        S.5....T.   c  /etc/httpd/conf/httpd.conf
        出现提示信息:最前面共有8个信息，表示验证内容；c表示这是一个配置文件
        (configuration file);最后是文件名。验证内容中的8个信息的具体含义如下：
            S: 文件大小是否改变
            M: 文件的类型或文件的权限（rwx)是否改变
            5: 文件的MD5校验和是否改变
            D: 设备的主从代码是否改变
            U: 文件的属主（所有者）是否改变
            G: 文件 的属组是否改变
            T: 文件的修改时间是否改变
        文件类型：
            c: 配置文件（configuration file)
            d: 普通文件（documentation)
            g: “鬼”文件（ghost file)，很少见，就是该文件不应该被这个RPM包含
            l: 授权文件（license file)
            r: 描述文件（read me)
   
        数字证书: 上面的校验方法只能对已经安装的RPM包中文件进行校验，但如果RPM
                  包本身就被动了手脚，必须使用数字证书验证。
            首先必须找到原厂的公钥文件，然后才能进行安装
            再安装RPM包,会去提取RPM包中的证书信息,然后和本机安装的原厂证书进行验证
            如果验证通过,则允许安装;如果验证不通过,则不允许安装并发出警告。
   
        ll /mnt/cdrom/RPM-GPG-KEY-CentOS-6  #光盘中的数据证书位置
        ll /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6 #系统中的数字证书位置
    
        安装数据证书的命令如下:
            rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6
  
        查询系统中安装好的数据证书的命令如下:
            rpm -qa|grep gpg-pubkey
    
        查询数字证书的详细信息:
            rpm -qi gpg-pubkdy-c105b9de-4e0fd3a3
     
       卸载数字证书: 
            rpm -e gpg-pubkdy-c105b9de-4e0fd3a3


>[返回目录](#目录)

    
#### 6_2_7
#### RPM包中的文件提取

```
        备份:
            cpio -o[vcB] >[文件|设备]
            选项:
                -o: copy-out 模式，备份
                -v: 显示备份过程
                -c: 使用较新的protable format存储方式
                -B: 设定输入/输出块为5120Bytes,而不是模式的512Bytes
        还原:
            cpio -i[vcdu] <[文件|设备]
            选项:
                -i: copy-in模式，还原
                -v: 显示还原过程
                -c: 使用较新的portable format存储方式
                -d: 还原时自动新建目录
                -u: 自动使用较新的文件覆盖较旧的文件
        eg:
            find /etc -print|cpio -ovcB>/root/etc.cpio
            cpio -idvcu </root/etc.cpio
            find . -print|cpio -ovcB>/root/etc.cpio
            cpio -idvcu </root/etc.cpio
    
        从RPM包中提取特定文件:
        rpm2cpio 包全名|cpio -idv .文件绝对路径
```            


>[返回目录](#目录)

    
#### 6_2_8
#### SRPM包的使用   

            SRPM包管理需要使用命令rpmbuild，默认这个命令没有安装。
            SRPM包有两种安装方式：一种是利用rpmbuild命令直接安装；另一种方式是
                利用*.spec文件安装。
        (1)rpmbuild命令安装
            rpmbuild [选项] 包全名
            选项:
                --rebuild: 编译SRPM包，不会自动安装，等待手工安装
                --recompile: 编译SRPM包，同时安装            
    
            eg: rpmbuild --rebuild httpd-2.2.15-e16.src.rpm
                子目录：
                    BUILD: 编译过程中产生的数据保存位置
                    RPMS: 编译成功后,生成的RPM包保存位置
                    SOURCES: 从SRPM包中解压出来的源码包（*.tar.gz)保存位置
                    SPECS: 生成的设置文件的安装位置。第二种方法利用这个文件安装
                    SRPMS: 放置SRPM包的位置
        (2)利用*.spec文件安装
            rpm -i httpd-2.2.15-e16.src.rpm
            rpm -ba /root/rpmbuild/SPECS/httpd.spec
            选项:
                -ba: 编译，同时生成RPM包和SRPM包
                -bb: 编译,公生成RPM包


>[返回目录](#目录)

    
#### 6_2_9
#### RPM包的深入应用

        rpm -qa|grep vim
        rpm -ql vim-common|grep example
        head -4 /usr/share/vim/vim70/vimrc_example.vim
    
        RPM数据库问题
            rm -f /var/lib/rpm/_db.*
            rpm --rebuilddb
    
        rpm -qf /etc/rc.d/init.d/smb
        qpm -ql --dump samba|grep /etc/rc.d/init.d/smb
           /etc/rc.d/init.d/smb  2087 1157165946 b1c26e529215  0100755 root root
           1 0 0 X
            2087为文件中最初的字符数 b1c26e529215为md5校验值 0755 root root权限



>[返回目录](#目录)

 
### 6_3
### RPM包管理--yum在线管理

        rpm -qa|grep yum

#### 6_3_1
#### yum源搭建

```
        vim /etc/yum.repos.d/CentOS-Media.repo
        [c6-media] #容器名称
        name=CentOS-$releasever-Media #容器说明
        #mirrorlist=http: #镜像站点,这个可以注释掉
        baseurl=file:///mnt/cdrom #yum源服务器的地址
        gpgcheck=1 #1表示RPM的数字证书生效;0不生效
        enabled=1 #1容器生效，0不生效
        gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6 #数字证书公钥文件
```        


>[返回目录](#目录)


#### 6_3_2
#### 常用yum命令 

 ```   
    #查询
        yum list 
        yum list 包名 
        yum search 关键字
        yum info 包名
    
    #安装
        yum -y install 包名
    #升级
        yum -y update #升级所有
        yum -y update 包名
    #卸载
        yum remove 包名
 ```       

#### 6_3_3
#### yum软件组管理

```
        yum grouplist
        yum groupinfo 软件组名
        yum groupinstall 软件组名
        yum groupremove 软件组名
```


>[返回目录](#目录)


### 6_4
### 源码包管理

#### 6_4_1
#### 源码包的安装准备

```
        rpm -q gcc
        yum -y install gcc
```   

#### 6_4_2
#### 源码包安装

        (1)下载软件包
        (2)解压缩
        (3)进入解压目录
        (4) ./configure 软件配置与检查
            ./configure --help
            ./configure --prefix=安装路径
        (5)make编译
        (6)make clean:清空编译内容
        (7)make install:安装


>[返回目录](#目录)


#### 6_4_3
#### 源码包升级

        diff 选项 old new
```
        选项:
            -a:  将任务文件当作文本文档处理
            -b:  忽略空格造成的不同
            -B:  忽略空白行造成的不同
            -I:  忽略大小写造成的不同
            -N:  当比较两个目录时，如果某个文件只在一个目录中，则在另一个目录
                 中视作空文件
            -r:  当比较目录时，递归比较子目录
            -u:  使用同一输出格式 
```
        eg: 生成补丁文件“txt.patch”
            diff -Naur /root/test/old.txt /root/test/new.txt >txt.patch
     
        使用补丁文件
        patch -pn <补丁文件
```
            选项:
                -pn: n为数字。代表按照补丁文件中的路径，指定更新文件位置
     
            "-pn"不好理解，我们说明一下。补丁文件是要打入旧文件的，但是你当前
            所在的目录和补丁文件中记录的目录不一定是匹配的,所以就需要"-pn"选项
            来同步两个目录。
     
            比如:当前目录为/root/test/（我要打补丁的旧文件就在当前目录下），
            补丁文件中记录的文件目录为"/root/test/old.txt"，这时应写入"-p3"
            可以这样理解：“-pn”就是想要在补丁文件中所记录的目录中取消几个"/"
```
        步骤：
            （1）下载补丁文件
             (2) 把补丁文件自制到目录
             (3) 打如补丁
             (4) 重新编译
             (5) 重新安装
     
        如果不想要补丁中的内容，可以恢复：
```    
    patch -R <mod_proxy_ftp_CVE-2008-2939.diff
    选项:
        -R: 还原补丁
```

diff比较文件常用格式
> 正常格式（normal diff）    
>> `diff f1 f2`
>
> 上下文格式（context diff） 
>> `diff -c f1 f2`
>
> 合并格式（unified diff）
>> `diff -u f1 f2`


>[返回目录](#目录)


#### 6_4_4
####  源码包卸载

```
    rm -rf /usr/local/apache2/
```

#### 6_4_5
#### 函数库管理

        *.a    *.so
    #可执行程序调用了哪些函数库呢?
```
    ldd -v 可执行文件名
    选项:
        -v: 显示详细版本信息
```        
    #新安装一个函数库
```
    cp *.so /usr/lib/
    vim /etc/ld.so.conf #将库所在目录写入o
    ldconfig #使用ldconfig命令重新读取/etc/ld.so.conf文件，把新函数库读入
                 #缓存
    ldconfig -p #列出系统缓存中所有识别的函数库
```    


>[返回目录](#目录)

 
### 6_5
### 脚本程序包管理

#### 6_5_1
#### 脚本程序简介

```
        tar -zxvf xxxx
        ./setup.sh
```    

#### 6_5_2
#### Webmin安装

### 6_6
### 软件包的选择



>[返回目录](#目录)


--------------------------------------------------

## 7
## 第7章 得人心者得天下:用户和用户组管理

### 7_1
### 用户配置文件和管理相关文件

#### 7_1_1
#### 用户信息文件/etc/passwd

        Linux中的所有内容都是文件，所有内容如果想要永久生效，都需要保存到文件中
        用":"作为分隔符，划分为7个字段:
            (1)用户名称
            (2)密码标志:"x"代表的是密码标志，而不是真正的密码；passwd文件权限
                        是644,为了安全把密码放到了000权限的shadow文件中；但x是
                        必须存在的,如果删除系统认为这个用户没有密码,从而导致本
                        机用户不用输入密码就可以登录.
            (3)UID: 0超级用户UID,在Linux中把普通用户UID修改为0可以变成超级用户
                    1~499是系统用户（伪用户）UID，是系统留给系统用户的UID，是
                    不能登录系统的,而是用来运行系统服务的.其中1~99是系统保留的
                    的账号,系统自动创建;100~499是预留给用户创建系统账号的。
                    500~65535普通用户UID。2.6.x内核以后的Linux系统用户可以2的
                    32次方个用户
            (4)GID: 用户组ID,初始组的标志号，与之相对就的是附加组。
                    所谓初始组，指用户一登录就立刻拥有这个用户组的相关权限。每
                        个用户只能有一个。            
                    所谓附加组,指用户可以加入多个其他的用户组,并拥有这些组的权
                        限.附加组可以有多个。
            (5)用户说明：没特殊作用，可以不写。
            (6)家目录:超级用户的家目录是/root，普通用户的家目录在/home目录下和
                      用户名相同的目录
            (7)登录之后的shell:可以把这个字段理解为用户登录之后所拥有的权限。
                                /bin/bash代表用户拥有权限范围内的所有权限
                                /sbin/nologin 用户不能登录
                                /usr/bin/passwd 只能修改自己的密码


>[返回目录](#目录)


#### 7_1_2
#### 影子文件/etc/shadow

            这个文件中保存着用户的实际的加密密码和密码有效期等参数.这个文件的
        权限是000，所以保存的实际加密密码除root用户外，其他用户不能查看的。
        
        每行代表一个用户,用":"分隔隔为9个字段。
        (1)用户名称
        (2)密码:真正加密的密码.目前Linux密码采用的是SHA512散列加密算法。原来采
                用的是MD5或DES加密算法。我们可以在密码前人为地加入"!"或"*"改
                变加密值让密码暂时失效,使这个用户无法登录,达到暂时禁止用户登录
                注意:所有伪用户的密码都是"!!"或"*"，代表没有密码不能登录。当然
                     新创建的用户如果不设定密码,那么它的密码项也是"!!",不能登录
        (3)密码最后一次修改日期:以1970-01-01作为标准时间，每过去一天时间戳加1
                                date -d "1970-01-01 15775 days" 换算成时间
                                echo $((date --date="2013/03/11" +%s)/86400+1))
        (4)密码的再次修改间隔时间(和第三个字段相比): 0代表可以随时修改，10代表
                                                     密码修改后10天之内不能修改
        (5)密码的有效期(和第三个字段相比)
               默认值是99999(天)，也就是273年，大家可以认为永久。过了有效期，用
               户就不能登录了.
        (6)密码修改到期前的警告天数(和第5个字段相比)
        (7)密码过期后的宽限天数(和第5个字段相比)
               也就是密码过期后,用户如果还是没有修改密码,那么在宽限的天数内用
           户还是可以登录系统的。0代表密码过期后立即失效，如果是-1代表密码永远
           不会失效
        (8)账号失效时间
               同样要写时间戳,也就是用1970-01-01进行时间换算。如果过了失效时间
           就算密码没有过期,用户也就失效,无法使用了。
        (9)保留
           这个字段目前没有使用。
    
        小提示:在Linux中，如果遗忘了密码，则可以启动进入单用户模式。这时即可
               以删除/etc/passwd文件中的密码标识字段，也可以删除/etc/shadown
               文件中的密码标识字段,都可以达到清空密码的目的。



>[返回目录](#目录)


#### 7_1_3
#### 组信息文件/etc/group

            记录组ID和组名的对应文件，用":"作分隔符，划分为4个字段：
          (1)组名
          (2)组密码标志
                 和/etc/passwd文件一样，这里的"x"仅仅是密码标识，真密码保存在
             /etc/gshadow文件中。用户组密码主要用来指定组管理员的，由于系统中
             的账号可能会非常多,root用户可能没有时间进行用户的组调整，这时可
             以给用户组指定组管理员,如果有用户需要加入或退出某用户组,则可以由
             该组的管理员替换root进行管理。但是这项功能目前很少使用，我们也很
             少设置组密码.如果需要赋予某用户调整某个用户组的权限,则可以使用
             sudo命令代替。
          (3)组ID(GID)
          (4)组中的用户
                需要注意的是,如果该用户组是这个用户的初始组,则该用户不会写入
             这个字段.也就是说,写入这个字段的用户是这个用户组的附加用户。


>[返回目录](#目录)

    
#### 7_1_4	
#### 组密码文件/etc/gshadow

            用":"分隔为4个字段：
            (1)组名
            (2)组密码:比对大多数用户来说,这个字段不是空就是"!",代表这个组没有合
                      法的组密码。
            (3)组管理员用户名
            (4)组中的附加用户

#### 7_1_5
#### 用户管理相关文件

        1. 用户的家目录:/home/用户名 或 /root
        2. 用户邮箱目录:/var/spool/mail/用户名
        3. 用户模板目录:/etc/skel


>[返回目录](#目录)

    
### 7_2	
### 用户管理命令

#### 7_2_1
#### 添加用户:useradd

```
        useradd [选项] 用户名
        选项:
            -u UID:    手工指定用户的UID
            -d 家目录: 手工指定用户的家目录
            -c 用户说明
            -g 组名：  手工指定用户的初始组
            -G 附加组
            -s shell
            -e 用户的失效日期，格式为 "YYYY-MM-DD" 即/etc/shadow文件第8个字段    
            -o 允许创建的用户的UID相同。如：useradd -u 0 -o usertest
            -m 建立用户时强制建立家目录
```
        useradd命令的默认值设定:/etc/default/useradd
            (1)GROUP=100
                Linux中默认用户组有两种机制：一种是私有用户组机制，系统会创建
             一个和用户名相同的用户组作为用户的初始组;另一种是公共用户组机制,
             系统用GID是100的用户组作为所有新建用户的初始组.目前我们采用的是
             私有用户组机制.
            (2)HOME=/home
                家目录默认位置  
            (3)INACTIVE=-1
                密码过期后的宽限天数，也就是/etc/shadow文件的第7个字段；-1代表
                新建立的用户密码永远不会失效
            (4)EXPIRE=
                这个选项是密码失效时间，也就是/etc/shadown文件的第8个字段。也
                就是说,用户到达这个日期后就会直接失效。使用时间戳来表示日期。
                默认值是空,代表所胡新建用户没有失效时间,永久有效。
            (5)SKEL=/etc/skel
                模板目录的位置
            (6)CREATE_MAIL_SPOOL=yes
                默认创建用户邮箱
    
        通过命令查看默认选项:useradd -D
        
        /etc/login.defs 第二个默认值文件
```    
            MAIL_DIR /var/spool/mail #邮箱位置
            PASS_MAX_DAYS 99999  #密码有效期,/etc/shadow 第5个字段
            PASS_MIN_DAYS 0      #两次密码修改间隔,/etc/shadow第4个字段
            PASS_MIN_LEN  5 #密码的最小长度，但现在用户登录验证被PAM模块取代
            PASS_WARN_AGE 7 #密码修改到期前的警告天数,/etc/shadown第6个字段
            UID_MIN   500
            UID_MAX   60000 #从2.6.x内核开始支持2的32次方个，但真正最大是600000
            GID_MIN   500
            GID_MAX   60000
            CREATE_HOME yes        #是否自动创建家目录
            UMASK  077             #建立用户家目录的默认权限
            USERGROUPS_ENAB yes    #删除用户时，是否删除用户的初始组
            ENCRYPT_METHOD SHA5112 #用户的密码使用SHA512散列模式加密
```   


>[返回目录](#目录)


#### 7_2_2
#### 修改用户密码:passwd

```
        passwd [选项] 用户名
        选项:
            -S:  查询用户密码的状态，也就是/etc/shadow文件内容，仅root用户可用
            -l:  暂时锁定用户。仅root用户可用
            -u:  解锁用户。仅root用户可用
            --stdin: 可以将通过管理输出的数据作为用户的密码。主要在批量添加用
                     户时使用    
```
        passwd锁定用户是在/etc/shadow密码项前加"!!"
    
        eg: echo "123"|passwd --stdin lamp


>[返回目录](#目录)


#### 7_2_3
#### 修改用户信息:usermod

```
        usermod [选项] 用户名
        选项:
            -u UID:    修改用户的UID
            -d 家目录: 修改用户的家目录
            -c 用户说明
            -g 组名：  手工指定用户的初始组
            -G 附加组
            -s shell
            -e 用户的失效日期，格式为 "YYYY-MM-DD" 即/etc/shadow文件第8个字段    
            -L 临时锁定用户（Lock)
            -U 解锁用户(Unlock)
```
        usermod锁定用户是在/etc/shadow密码项前加"!"
    
        eg: usermod -G root manager


>[返回目录](#目录)


#### 7_2_4
#### 修改用户密码状态:chage

        通过chage命令可以查看和修改/etc/shadow文件的第3到第8个字段的密码状态
        cahage命令有一种很好的用法，就是强制用户在第一次登录时必须修改密码
```        
        chage [选项] 用户名
        选项:
            -l:  列出用户的详细密码状态
            -d 日期：密码最后一次修改日志(/etc/shadow文件第3字段）,格式：
                     YYYY-MM-DD
            -m 天数：密码的两次修改间隔时间（第4个字段)
            -M 天数：密码的有效期（第5个字段）
            -W 天数：密码修改到期前的警告天数（第6个字段）
            -I 天数：密码过期后的宽限天数（第7个字段）
            -E 日期：账号失效时间（第8个字段），格式为：YYYY-MM-DD
```
        eg: chage -d 0 lamp  #用户一登录就要修改密码


>[返回目录](#目录)



#### 7_2_5
#### 删除用户:userdel

```
        userdel [选项] 用户名
        选项:
            -r:在删除用户的同时删除用户的家目录
```

#### 7_2_6
#### 查看用户的UID和GID:id

```
        id  用户名
```   

#### 7_2_7
#### 切换用户身份:su

```
        su [选项] 用户名
        选项:
            -: 代表连带用户的环境变量一起切换
            -c 命令: 仅执行一次命令，而不切换用户身份
```    


>[返回目录](#目录)


### 7_3
### 用户组管理命令

#### 7_3_1
#### 添加用户组:groupadd

```
        groupadd [选项] 组名
        选项:
            -g GID:指定组ID
```

#### 7_3_2
#### 修改用户组:groupmod

```
        groupmod [选项] 组名
        选项:
            -g GID: 修改组ID
            -n 新组名：修改组名
```

#### 7_3_3
#### 删除用户组:groupdel

```
        groupdel 组名
```
        注意:要删除的组不能是其他用户的初始组


>[返回目录](#目录)

   
#### 7_3_4   
#### 把用户添加进组或从组中删除:gpasswd

            gpasswd命令是用来设定组密码并指定管理员的，不过现在gpasswd主要用于
        把用户添加进组或从组中删除。

```
        gpasswd 选项  组名
        选项:
            -a 用户名: 把用户加入组
            -d 用户名：把用户从组中删除
```
        eg: gpasswd -a lamp gruoptest
            gpasswd -d lamp grouptest
            usermod -G grouptest lamp


>[返回目录](#目录)


#### 7_3_5
#### 改变有效组:newgrp

        当用户属于多个组时,创建文件时默认生效的是初始组,使用newgrp命令可以在多个
    身份之间切换。

```
        newgrp 组名
```   


>[返回目录](#目录)


   
--------------------------------------------------

## 8
## 第8章 坚若磐石的防护之道:权限管理

### 8_1
### ACL权限

        ACL是Access Control List(访问控制列表)的缩写，不过在Linux系统中，ACL用
    于设定用户针对文件的权限,而不是在交换机和路由器中用来控制数据访问的功能。

#### 8_1_1
#### 开启ACL权限

        在CentOS6.x系统中ACL权限默认是开启的。
        如何查看ACL权限是否开启:
```
            dumpe2fs -h /dev/sda3
            ……
            Default mount options: user_xattr acl
            ……
            
            mount -o remount,acl /  #重新挂载根分区，并加入ACL权限
```   


>[返回目录](#目录)


#### 8_1_2
#### ACL权限设置

```    
        getfacl 文件名  #查看ACL权限
        setfacl 选项 文件名  #设定ACL权限
        选项:
            -m: 设定ACL权限。如果是给予用户ACL权限，则使用"u:用户名:权限"格式
                赋予；如果是给予组ACL权限，则使用"g:组名:权限"格式赋予
            -x: 删除指定的ACL权限
            -b: 删除所有的ACL权限
            -d: 设定默认ACL权限。只对目录生效，指目录中新建立的文件拥有此默认
                权限
            -k: 删除默认ACL权限
            -R: 递归设定ACL权限。指设定的ACL权限会对目录下的所有子文件生效
```

        eg:
            setfacl -m u:st:rx /rpject/
            getfacl project
            setfacl -m g:tgroup2:rwx project/
            setfacl -m m:rx project/ #设定mask权限为r-x，使用"m:权限"格式
    
            ll 查看权限，权限位后面没有"+"，表示没有ACL权限
            setfacl -m d:u:st:rx /project/
            setfacl -m u:st:rx -R /project/
    
        默认ACL权限指的是针对父目录中新建立的文件和目录会继承父目录的ACL权限
        递归ACL权限指的是针对父目录中已经存在的所有了文件和子目录继承父目录        
    
            setfacl -x u:st /project/ #删除指定用户和用户组的ACL权限
            setfacl -b project/ #会删除文件的所有ACL权限


>[返回目录](#目录)


### 8_2
### 文件特殊权限--SetUID SetGID StickyBIT

#### 8_2_1
#### 文件特殊权限之 SetUID

        在属主本来应该写x权限的位置出现了一个不写s
        1、只有可以执行的二进制程序才能设定SetUID权限
        2、命令执行者要对该程序拥有x权限
        3、命令执行者在执行该程序时获得该程序文件属主的身份
        4、SetUID权限只在该程序执行过程中有效。
```
        chmod u-s /usr/bin/passwd
        chmod u+s /usr/bin/passwd
        find / -perm -4000 -o -perm -2000
```


>[返回目录](#目录)


#### 8_2_2
#### 文件特殊权限之 SetGID

        s标志在属组的x位置时是SetGID
        SetGID既可以针对文件生效，也可以针对目录生效，这和SetUID明显不同。
    一、对文件:
        1.只有可执行的二进制程序才能设置SetGID权限。
        2.命令执行者要对该程序拥有x权限
        3.命令执行者在执行程序的时候,组身份升级为该程序文件的属组
        4.SetGID权限同样只在该程序执行过程中有效。

        ll /usr/bin/locate
    
    二、对目录:
        1.普通用户必须对此目录拥有r和x权限，才能进入此目录
        2.普通用户在此目录中的有效组会变成此目录的属组
        3.苦普通用户对此目录拥有w权限，则新建文件的默认属组是这个目录的属组。
```
        chmod g+s xxxx
        chmod g-x xxxx
```


>[返回目录](#目录)


#### 8_2_3
#### 文件特殊权限之 StickyBIT

        Sticky BIT意为粘着位，也简称为SBIT,作用如下：
        1.粘着位目前只对目录有效
        2.普通用户对该目录拥有w和x权限，即普通用户可以在此目录中拥有写入权限。
        3.一旦被赋予了粘着位,除了root可以删除所有文件，普通用户就算拥有w权限，
            只也能删除自己建立的文件,而不能删除其他用户建立的文件。
			
```
        chmod o+t xxxx
        chmod o-t xxxx
```


>[返回目录](#目录)


#### 8_2_4
#### 特殊权限设置
    
        4代表SetUID
        2代表SetGID
        1代表SBIT
    需要注意：特殊权限只针对具有可执行权限的文件有效，不具有x权限的文件被赋予了
              SetUID和SetGID权限会被标记为S，SBIT权限会被标记为T


>[返回目录](#目录)


### 8_3   
### 文件系统属性chattr权限

#### 8_3_1
#### 设定文件系统属性chattr

        chattr只有root用户可以使用，用来修改文件系统的权限属性，建立凌驾于rwx
    基础权限之上的授权.

```
        chattr [+-=] [选项] 文件或目录名
        选项:
            +: 增加权限
            -: 删除权限
            =: 等于某权限
            i: 如果对文件设置i属性，那么不允许对文件进行删除、改名、也不能添加
               和修改数据；如果对目录设置i属性，那么只能修改目录下文件中的数据
               ,但不允许建立和删除文件
            a: 如果对文件设置a属性，那么只能在文件中增加数据，但是不能删除和修
               改数据；如果对目录设置a属性，那么只允许在目录中建立和修改文件，
               但不允许删除文件
            e: Linux中的绝大多数文件都默认拥有e属性，表示该文件是使用ext文件进
               行存储的,而且不能使用"chattr -e"命令取消属性
```   


>[返回目录](#目录)


#### 8_3_2
#### 查看文件系统属性lsattr

```   
        lsattr 选项  文件名
        选项:
            -a: 显示所有文件和目录
            -d: 如果目标是目录，则仅列出目录本身的属性，而不会列出文件的属性
```


>[返回目录](#目录)


### 8_4
### 系统命令sudo权限

#### 8_4_1
#### sudo用法

        sudo的操作对象是系统命令，也就是root把本来只能由超级用户执行的命令赋予
    普通用户执行
        sudo使用简单，管理员root使用visudo命令即可编辑其配置文件/etc/sudoers
    进行授权
        vidudo

```
        root     ALL=(ALL)    ALL
        #用户名  被管理主机的地址=(可使用的身份)  授权命令（绝对路径）
        #%wheel  ALL=(ALL)  ALL
        #%组名  被管理主机的地址=（可使用的身份） 授权命令（绝对路径）
```

    4个参数的具体含义如下:
    (1)用户名/组名：代表root给哪个用户或用户组赋予命令，注意组名前加"%"
    (2)用户可以用指定的命令管理指定IP地址的服务器。如果写ALL,则代表用户可以管理
       任何主机;如果写固定IP，则代表用户可以管理指定的服务器。如果我们在这里写
       本机的IP地址，则不代表只允许本机的用户使用指定的命令，而代表指定的用户
       可以从任何IP地址来管理当前服务器。
    (3)可使用的身份:就是把来源用户切换成什么身份使用,(ALL)代表可以切换成任意身
       份.这个字段可以省略.
    (4)授权命令:代表root把什么命令授权给普通用户。默认是ALL，代表任何命令，这
       当然不行.如果需要给哪个命令授权,则只需写入命令名即可.不过需要注意,一定
       要写成绝对路径.


>[返回目录](#目录)


#### 8_4_2
#### sudo举例

        很多人使用sudo会犯两类错误：
        第一:授权命令没有细化到选项和参数;
        第二：认为只能授权管理员执行的命令。




>[返回目录](#目录)


    
--------------------------------------------------

## 9
## 第9章 牵一发而动全身:文件系统管理

### 9_1
### 硬盘结构

    机械硬盘(Hard Disk Drive,HDD):采用磁性碟片来存储数据
    固态硬盘(Solid State Disk,SSD):通过闪存颗粒来存储数据

#### 9_1_1
#### 机械硬盘(HDD)

```    
        硬盘大小:磁头数(Heads)*柱面数(Cylinders)*扇区数(Sectors)*每个扇区大小（
                 一般是512Byte)
        硬盘接口:
                IDE硬盘接口(Integrated Drive Electronics,并口，即电子集成驱动器
                           )也称作"ATA硬盘"或"PATA硬盘" 理论速度可达到133MB/s
                SATA接口(Serial ATA,串口）更高传输速度，更强纠错能力，理论传输
                    速度达到600MB/s
                SCSI接口(Small Computer System Interface,小型计算机系统接口）理
                    论传输速度320MB/s
```


>[返回目录](#目录)


#### 9_1_2
#### 固态硬盘(SSD)

        固态硬盘的存储芯片主要分为两种:一种是采用闪存用为存储介质的;另一种是采
    用DRAM作为存储介质。目前使用较多的主要是采用闪存作为存储介质的固态硬盘。


>[返回目录](#目录)


### 9_2
### Linux中常见的文件系统

#### 9_2_1
#### 文件系统的特性

        ext4文件系统是由Theodore Tso(ext3的维护者）领导的开发团队实现的，并引入
    2.6.19内核中.
        super block(超级块）：记录整个文件系统的信息，包括block与inode的总量、
    已经 使用的inode和block的数量、未使用的inode和block的数量、block与inode的大
    小、文件 系统的挂载时间、最近一次的写入时间、最近一次的磁盘检验时间等。
        date block(数据块，也称作block):用来实际保存数据，block的大小（1KB 2KB
    或4KB)和数量在格式化后就已经决定,不能改变,除非重新格式化.每个block只能保存
    一个文件的 数据，如果文件数据小于一个block块，那么这个block的剩余空间不能被
    其他文件使用； 如果文件数据大于一个block块，则要占用多个block块。windows中
    磁盘碎片整理工具的原 理就是把一个文件占用的多个block块尽量整理到一起，这样
    可以加快读/写速度。
        inode(i节点):用来记录文件的权限（r w x)、文件的所有者和属组、文件的大
    小、 文件的状态改变时间（ctime)、文件的最近一次读取时间（atime）、文件的最
    近一次修改 时间（mtime）、文件的数据真正保存的block编号。每个文件需要占用一
    个inode。


>[返回目录](#目录)


#### 9_2_2
#### Linux支持的常见文件系统

```
    ext     Linux中最早的文件系统,由于在性能和兼容性上具有很多缺陷,现在已经很少
            使用        

    ext2    是ext文件系统的升级版本，Red Hat Linux7.2版本以前的系统默认都是
            ext2文件系统.于1993年发布,支持最大16TB的分区和最大2TB的文件

    ext3    是ext2文件系统的升级版本，最大的区别就是带日志功能，以便在系统突然
            停止时提高文件系统的可靠性.支持最大16TB的分区和最大2TB的文件

    ext4    是ext3文件系统的升级版。ext4在性能、伸缩性和可靠性方面进行了大量改
            进。ext4的变化可以说是翻天覆地的，比如向下兼容ext3、最大1EB文件系
            统和16TB文件、无限数量子目录、Extents连续数据块概念、多块分配、延迟
            分配、持久预分配、快速FSCK、日志校验、无日志模式、在线碎片整理、
            inode增强、默认启用barrier等。它是CentOS6.3的默认文件系统

    swap    swap是Linux中用于交换分区的文件系统（类似于windows中的虚拟内在），
            当内存不够用时，使用交换分区暂时替代内存。一般大小为内存的2倍，但
            不要超过2GB,它是Linux的必需分区

    NFS     NFS是网络文件系统（NetWork File System)的缩写，是用来实现不同主机
            之间文件共享的一种网络服务,本地主机可以通过挂载的方式使用远程共享
            的资源

    iso9660 光盘的标准文件系统。Linux想要使用光盘，必须支持iso9660文件系统

    fat     就是windows下的fat16文件系统，在Linux中识别为fat

    vfat    就是windows下的fat32文件系统，在Linux中识别为vfat。支持最大32GB的
            分区和最大4GB的文件

    NTFS    就是windws下的NTFS文件系统，不过Linux默认是不能识别NTFS文件系统的
            ,如果需要识别,则需要重新编译内核才能支持.它比fat32文件系统更加安全
            ，速度更快，支持最大2TB的分区和最64GB的文件

    ufs     Sun公司的操作系统Solaris和SunOS所采用的文件系统

    proc    Linux中基于内存的虚拟文件系统，用来管理内存存储目录/proc

    sysfs   和proc一样，也是基于内存的虚拟文件系统，用来管理内存存储目录/sysfs

    tmpfs   也是一种基于内存的虚拟文件系统，不过也可以使用swap交换分区
```


>[返回目录](#目录)


### 9_3
### 回顾硬盘分区

#### 9_3_1
#### 硬盘分区的类型

        主分区:最多只能分为4个
        扩展分区:只能有一个,也算作主分区的一种
        逻辑分区:逻辑分区是在扩展分区中划分。IDE硬盘Linux最多支持59个逻辑分区；
                 SCSI硬盘,Linux最多支持11个逻辑分区。

#### 9_3_2
#### Linux中硬盘与分区的表示方式

        在Linux系统中，所有内容都是以文件方式保存的。硬盘和分区也是一样的。我
    们使用"sd"代表SCSI或SATA硬盘,使用"hd"代表IDE硬盘。使用"1~4"代表主分区或扩
    展分区,使用"5~59"代表逻辑分区。


>[返回目录](#目录)


### 9_4
### 文件系统常用命令

#### 9_4_1
#### 文件系统查看命令df

```
        df  [选项] [挂载点或分区设备文件名]
        选项:
            -a:显示所有文件系统信息，包括特殊文件系统，如/proc、/sysfs
            -h:使用习惯单位显示容量，如KB、MB、或GB等
            -T:显示文件系统类型
            -m:以MB为单位显示容量
            -k:以KB为单位显示容量。默认以KB为单位
```


>[返回目录](#目录)


#### 9_4_2
#### 统计目录或文件所占磁盘空间大小命令du

        需要注意的是,使用"ls -l"命令是可以看到文件的大小的。但是大家会发现，在
    使用"ls -l"命令查看目录大小时，目录的大小多数是4KB，这是因为目录下的子目录
    名和子文件名是保存到父目录的block(默认大小为4KB)中的，如果父目录下的子目录
    和子文件并不多,一个block就能放下，那么这个父目录就只占用了一个block大小。
        想看父目录和子文件的总磁盘占用量大小,用du命令统计
```
        du [选项] [目录或文件名]
        选项:
            -a:显示每个子文件的磁盘占用量。默认只统计了目录的磁盘占用量
            -h:使用习惯单位显示磁盘占用量，如KB、MB、或GB等
            -s:统计总磁盘占用量，而不列出子目录和子文件的磁盘占用量
```    
        du命令和df命令的区别：
            df命令是从文件系统的角度考虑的，通过文件系统中未分配的空间来确定文
            件系统中已经分配的空间大小。也就是说,在使用df命令统计分区时，不仅
            要考虑文件占用的空间,还要统计被命令或程序占用的空间(最常见的就是文
            件已经删除,但是程序并没有释放空间)。
            du命令是面向文件的，只会计算文件或目录占用的硬盘空间。
            也就是说,df命令统计的分区更准确，是真正的空闲空间。


>[返回目录](#目录)


#### 9_4_3
#### 挂载命令mount和卸载命令umount

        Linux中所有的存储设备都必须挂载之后才能使用。
        挂载是指把硬盘分区(其实指的是文件系统)和挂载点(已经建立的空目录)联系起
    来的过程。
    
        mount 命令的基本格式
```
            mount [-l]  #查询系统中已经挂载的设备，-l会显示卷标名称
            mount -a #依据配置文件/etc/fstab的内容，自动挂载
            mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点
            选项：
             -t 文件系统：加入文件系统类型来指定挂载的类型。
             -L 卷标名：挂载指定卷标的分区，而不是安装备文件名挂载
             -o 特殊选项：可以指定挂载的选项，比如读写权限、同步/异步等，如果
                不指定,则默认值生效.具体的特殊选项参见下表
```
        mount命令挂载特殊选项：
```
        atime/noatime 更新访问时间/不更新访问时间。在访问分区文件时，是否更新
                      文件的访问时间，默认为更新

        async/sync    异步/同步，默认为异步

        auto/noauto   自动/手动。如mount -a命令执行时，是否会自动安装/etc/fstab
                      文件内容挂载,默认为自动

        default       定义默认值，相当于rw suid dev exec auto nouser async 这
                      7个选项

        exec/noexec  执行/不执行。设定是否允许在文件系统中执行可执行文件，默认
                     是允许
     
        remount       重新挂载已经挂载的文件系统，一般用于指定修改特殊权限

        rw/ro         读写/只读。文件系统挂载时，是否拥有读写权限，默认是rw

        suid/nosuid  具有/不具有SetUID权限。设定文件系统是否拥有SetUID和SetGID
                     权限，默认是拥有

        user/nouser  允许/不允许普通用户挂载。设定文件系统是否允许普通用户挂载
                     ,默认是不允许,只有root可以挂载分区

        usrquota     写入代表文件系统支持用户磁盘配额，默认不支持

        grpquota     写入代表文件系统支持组磁盘配额，默认不支持
```
        eg: mount -t vfat -o iocharset=utf8 /dev/sdb1 /mnt/usb/
    
        注:Linux默认是不支持NTFS文件系统的，所以默认是不能挂载NTFS格式的移动硬
           盘的。要想让Linux支持移动硬盘，主要有三种方法：
           1.重新编译内核,加入ntfs模块，然后安装ntfs模块即可；
           2.下载已经编译好的内核,直接安装即可;
           3.安装NTFS文件系统的第三方插件。
                      
        卸载命令: umont 设备文件名或挂载点


>[返回目录](#目录)


#### 9_4_4
#### 文件系统检测与修复命令fsck

```
        fsck [选项] 分区设备文件名
        选项:
            -t 文件系统：指定分区的文件系统
            -A: 按照配置文件/etc/fstab检查所有分区
            -a: 不用显示用户提示，自动修复文件系统            
            -C: 显示检查分区的进度条
            -f: 强制检测，一般fsck命令如果没有发现分区有问题，则是不会检测的，
                如果强制检测,那么不管是否发现问题,都会检测
            -y: 自动修复。和-a作用一致，不过有些文件系统只支持-y
```


>[返回目录](#目录)


#### 9_4_5
#### 显示硬盘状态命令dumpe2fs

```
        dumpe2fs /dev/sda3
```


>[返回目录](#目录)


### 9_5
### fdisk命令分区

      在Linux中有专门的分区命令fdisk和parted。其中fdisk命令较为常用，但不支持大
    于 2TB的分区;如果需要支持大于2TB的分区,则需要使用parted命令，当然parted命令
    也 能分配较小的分区.
    分区共需要以下几个步骤：
        添加新硬盘
        创建分区
        格式化分区
        建立挂载点并挂载
        实现开机后自动挂载


>[返回目录](#目录)


#### 9_5_1
#### 添加新硬盘

#### 9_5_2
#### 创建分区

```
        fdisk -l #列出系统分区
        fdisk 设备文件名 #给硬盘分区
            
        fdisk交互命令：
          a 设置可引导标记
          b 编辑bsd磁盘标签
          c 设置dos操作系统兼容标记
          d 删除一个分区
          l 显示已知的文件系统类型。82为Linux swap分区，83为Linux分区
          m 显示帮助菜单
          n 新建分区
          o 建立空白dos分区表
          p 显示分区列表
          q 不保存退出
          s 新建空白SUN磁盘标签
          t 改变一个分区的系统ID
          u 改变显示记录单位
          v 验证分区表
          w 保存退出
          x 附加功能(仅专家)
```    
        fdisk 硬盘名-->n(新建)-->p(建立主分区)-->1(指定分区号)-->回车(默认从1
        柱面开始建立分区)-->+5G(指定分区大小)
    
        partprobe #这个命令的作用是让系统内核重新读取分区表信息，这样可以不重新
                  #启动


>[返回目录](#目录)


#### 9_5_3
#### 格式化分区

```
        mkfs [选项] 分区设备文件名
        选项：
            -t 文件系统：指定格式化的文件系统，如ext3 ext4
        eg: mkfs -t ext4  /dev/sdb6
```

        mkfs命令非常简单易用，不过是不能调整分区的默认参数（比如块大小是4096
        Bytes),这些默认参数除非特殊情况，否则不需要调整。如果需要调整使，就
        需要使用 mke2fs命令重新格式化。

```
        mke2fs [选项] 分区设备文件名
        选项:
            -t 文件系统：指定格式化成哪个文件系统，如ext2 ext3 ext4
            -b 字节：指定block的大小
            -i 字节：指定“字节/inode”的比例，也就是多少字节分配一个inode
            -j ：建立带ext3日志功能的文件系统
            -L 卷标名: 给文件系统设置卷标名,就不使用e2label命令设定了
```


>[返回目录](#目录)


#### 9_5_4
#### 建立挂载点并挂载

```
        mkdir /disk5
        mount /dev/sdb5 /disk5/
```


>[返回目录](#目录)


#### 9_5_5
#### 实现开机后自动挂载

        需要修改系统的自动挂载文件/etc/fstab,不过要小心这个文件会影响系统的启动
    。这个文件共用6个字段：

```
        proc  /proc  proc defaults 0 0
        1、第一个字段：分区设备文件名或UUID(硬盘通用唯一识别码，可以理解为硬盘
           的ID)。
           UUID可以通过dumpe2fs命令得到，也可以通过UUID的链接文件名来确定：
           ls -l /dev/disk/by-uuid/
        2、第二个字段:挂载点。（应该是已经建立的空目录）
        3、第三个字段:文件系统名称,CentOS6.3的默认文件系统应该是ext4
        4、第四个字段:挂载参数,这个参数和mount命令的挂载参数一致.
        5、第五个字段:指定分区是否被dump备份，0代表不备份，1代表每天备份，2代表
           不定期备份.
        6、第六个字段:指定分区是否被fsck检测，0代表不检测，其他数字代表检测的
           优先级,1的优先级比2高。所以先检测1的分区,再检测2的分区。一般根分区
           的优先级1,其他分区的优先级是2。    
```


>[返回目录](#目录)


### 9_6
### /etc/fstab文件修复

```
    mount -o remount,rw / #把/分区重新挂载上读写权限就可以修改了
```


>[返回目录](#目录)


### 9_7
### parted命令分区

      在Linux系统中有两种常见的分区表：MBR分区表（主引导记录分区表）和GPT分区表
    (GUID分区表）。
      MBR分区表：支持的最大分区是2TB；最多支持4个主分区，或3个主分区1个扩展分区
      GPT分区表: 支持最大18EB的分区(1EB=1024PB=1024*1024TB)；最多支持128个分区
                 ,其中1个系统保留分区,127个用户自定义分区。 
      fdisk工具不支持GPT分区表，总有一天2TB的分区不够用，这时可用parted命令进行
    系统分区了。不过parted命令也有一点小问题，就是命令自身分区的时候只能格式化
    成ext2文件系统。(parted命令可以识别ext4文件系统，但不能格式化),不过可以先
    分区再用mkfs命令进行格式化。

#### 9_7_1
#### parted交互模式

        parted命令是可以在命令行直接分区的格式化的，不过parted交互模式才是更加
    常用的命令方式。

```
        parted 硬盘设备文件名 #进入交互模式
        parted交互命令比较多，常见命令如下：
            check NUMBER 做一次简单的文件系统检测
            cp [FROM-DEVICE] FROM-NUMBER TO-NUMBER 复制文件系统到另一个分区
            help [COMMAND] 显示所有的命令帮助
            mklabel,mktable LABEL-TYPE 创建新的磁盘卷标(分区表)
            mkfs NUMBER FS-TYPE 在分区上建立文件系统
            mkpart PART-TYPE [FS-TYPE] START END 创建一个分区
            mkpartfs PART-TYPE FS-TYPE START END 创建分区，并建立文件系统
            move NUMBER START END 移动分区
            name NUMBER NAME 给分区命名
            print [devices|free|list,all|NUMBER] 显示分区表、活动设备、空闲空间
                                                 、所有分区
            quit 退出
            rescue START END 修复丢失的分区
            resize NUMBER START END 修改分区大小
            rm NUMBER 删除分区
            select DEVICE 选择需要编辑的设备
            set NUMBER FLAG STATE 改变分区标记
            toggle [NUMBER] [FLAG]切换分区表的状态
            unit UNIT 设置默认的单位
            Version 显示版本
```


>[返回目录](#目录)


#### 9_7_2
#### parted命令的使用

    eg:
        print #查看分区表
        mklabel gpt #修改成GPT分区表
        mkpart #建立分区
        mkfs #建立文件系统 
        resize #调整分区大小
    注意:parted调整已经挂载使用的分区时，是不会影响分区中的数据的，也就是说，数
        据不会丢失。但是一定要先卸载分区，再调整分区大小，否则数据是会出现问题
        的.另外,要调整大小的分区必须已经建立了文件系统(格式化),否则会报错.
        
        rm  #删除分区
   
    要注意的是,parted中所有的操作都是立即生效的，没有保存生效的概念。
    


>[返回目录](#目录)


### 9_8
### 分配swap分区

    swap分区是Linux系统的交换分区，当内在不够用的时候，使用swap分区存入内存中
暂时不用的数据。
    建议swap分区大小是内存的两倍，但不超过2GB.
    但有时候服务器的访问量确实很大,有可能出现swap分区不够用的情况。
    **建立新的swap分区步骤**：
        1.分区:不管是fdisk还是parted，先建立一个分区
        2.格式化:使用mkswap命令把分区格式化成swap分区
        3.使用swap分区


>[返回目录](#目录)


#### 9_8_1
#### 分区

```
        fdisk /dev/sdb
            n #新建
            p #主分区
            1 #分区编号
              #起始柱面
            p #查看一下
            t #修改分区的系统ID （83 Linux,82 swap)
            1 #只有一个分区,所以不用选择分区了
            82#修改为swap分区的ID
            p #再查看一下
            w #记得保存退出
```

#### 9_8_2
#### 格式化

```
        mkswap /dev/sdb1
```


>[返回目录](#目录)


#### 9_8_3
#### 使用swap分区

        free命令:主要用来查看内存和swap分区的使用情况。
        buffer(缓冲):是给写入数据加速的。先把分散的写入操作保存到内存，当达到
                     一定程度后再集中写入硬盘,减少了磁盘碎片和硬盘的反复寻道.
        cached(缓存):是给读取数据时加速的。把读取出来的数据保存在内存中，当再
                     次读取时,不用读取硬盘而直接从内存中读取.
        swapon /dev/sdb1  #加入swap分区
        wwapoff /dev/sdb1 #取消加入的swap分区
        开机之后自动挂载,需要修改/etc/fstab文件
            /dev/sdb1   swap  swap defaults  0 0




>[返回目录](#目录)


    
