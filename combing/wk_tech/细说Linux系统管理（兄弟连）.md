细说Linux系统管理（兄弟连）


# 细说Linux系统管理（兄弟连）

--------------------------------------------------

## 目录

* [第1章 运筹帷幄,操控全盘:高级文件系统管理](#1)
	* [1.1 磁盘配额](#1_1)
		* [1.1.1 什么是磁盘配额](#1_1_1)
		* [1.1.2 磁盘配额中的常见概念](#1_1_2)
		* [1.1.3 磁盘配额的实现过程](#1_1_3)
		* [1.1.4 磁盘配额的查询](#1_1_4)
		* [1.1.5 磁盘配额的测试](#1_1_5)
		* [1.1.6 非交互设定用户磁盘配额](#1_1_6)
	* [1.2 LVM(逻辑卷管理)](#1_2)
		* [1.2.1 LVM的概念](#1_2_1)
		* [1.2.2 图形界面安装系统时配置LVM分区](#1_2_2)
		* [1.2.3 命令模式管理LVM--物理卷管理](#1_2_3)
		* [1.2.4 命令模式管理LVM--卷组管理](#1_2_4)
		* [1.2.5 命令模式管理LVM--逻辑卷管理](#1_2_5)
	* [1.3 RAID(磁盘陈列)](#1_3)
		* [1.3.1 RAID简介](#1_3_1)
		* [1.3.2 图形界面安装系统时配置RAID](#1_3_1)
		* [1.3.3 命令模式配置RAID 5 ](#1_3_1)

* [第2章 化简单为神奇：Shell基础](#2)
	* [2.1 Shell概述](#2_1)
		* [2.1.1 什么是Shell](#2_1_1)
	* [2.2 Shell脚本的运行方式](#2_2)
	* [2.3 Bash的基本功能](#2_3)
	* [2.4 Bash的变量和运算符](#2_4)
	* [2.5 环境变更配置文件](#2_5)
	
* [第3章 管理员的九阳神功：Shell编程](#3)
	* [3.1 正则表达式](#3_1)
	* [3.2 字符截取和替换命令](#3_2)
	* [3.3 字符处理命令](#3_3)
	* [3.4 条件判断](#3_4)
	* [3.5 流程控制](#3_5)
	
* [第4章 庖丁解牛,悬丝诊脉:Linux启动管理](#4)
	* [4.1 CentOS 6.x系统启动过程详解](#4_1)
		* [4.1.1 CentOS6.x基本启动流程](#4_1_1)
		* [4.1.2 BIOS自检](#4_1_2)
		* [4.1.3 MBR的结构](#4_1_3)
		* [4.1.4 启动引导程序的作用](#4_1_4)
	* [4.2 启动引导程序（Boot Loader) ](#4_2)
	* [4.3 内核模块管理](#4_3)
	* [4.4 系统修复模式](#4_4)
	
* [第5章 掌柜先生敲算盘:服务管理](#5)
	* [5.1 服务的简介与分类](#5_1)
		* [5.1.1 服务的分类和区分](#5_1_1)
		* [5.1.2 服务的端口](#5_1_2)
	* [5.2 RPM包默认安装的服务管理](#5_2)
		* [5.2.1 独立服务的管理](#5_2_1)
		* [5.2.2 基于xinetd服务的管理](#5_2_2)
	* [5.3 源码包安装的服务管理](#5_3)
		* [5.3.1 源码包服务的启动管理](#5_3_1)
		* [5.3.2 源码包服务的自启动管理](#5_3_2)
		* [5.3.3 让源码包服务被服务管理命令识别](#5_3_3)
	* [5.4 总结服务管理](#5_4)
	* [5.5 Linux中常见服务的作用](#5_5)
	
* [第6章 七剑下天山:系统管理](#6)
	* [6.1 进程管理](#6_1)
		* [6.1.1 进程简介](#6_1_1)
		* [6.1.2 进程的查看](#6_1_2)
		* [6.1.3 进程的管理](#6_1_3)
		* [6.1.4 进程的优先级](#6_1_4)
	* [6.2 工作管理](#6_2)
		* [6.2.1 工作管理简介](#6_2_1)
		* [6.2.2 如何把命令放入后台](#6_2_2)
		* [6.2.3 后台命令管理](#6_2_3)
	* [6.3 系统资源查看](#6_3)
		* [6.3.1 vmstat命令：监控系统资源](#6_3_1)
		* [6.3.2 dmesg命令：显示开机时的内核检测信息](#6_3_2)
		* [6.3.3 free命令:查看内存使用状态](#6_3_3)
		* [6.3.4 查看CPU信息](#6_3_4)
		* [6.3.5 查看本机登录用户信息](#6_3_5)
		* [6.3.6 uptime命令](#6_3_6)
		* [6.3.7 查看系统与内核的相关信息](#6_3_7)
		* [6.3.8 lsof命令：列出进程调用或打开的文件信息](#6_3_8)
	* [6.4 系统定时任务](#6_4)
		* [6.4.1 t命令：一次性执行定时任务](#6_4_1)
		* [6.4.2 crontab 命令：循环执行定时任务](#6_4_2)
		* [6.4.3 anacron](#6_4_3)
	
* [第7章 凡走过必留下痕迹:日志管理](#7)
	* [7.1 日志简介](#7_1)
		* [7.1.1 日志相关服务](#7_1_1)
		* [7.1.2 系统中常见的日志文件](#7_1_2)
	* [7.2 日志服务rsyslogd](#7_2)
		* [7.2.1 日志文件的格式](#7_2_1)
		* [7.2.2 rsyslogd服务的配置文件](#7_2_2)
	* [7.3 日志轮替](#7_3)
		* [7.3.1 日志文件的命名规则](#7_3_1)
		* [7.3.2 logrotate配置文件](#7_3_2)
		* [7.3.3 把自己的日志加入日志轮替](#7_3_3)
		* [7.3.4 logrotate命令](#7_3_4)
	* [7.4 日志分析工具](#7_4)
	
* [第8章 搭台唱戏:LAMP环境搭建和LNMP环境搭建](#8)

* [第9章 常在河边走,哪有不湿鞋:备份与恢复](#9)
	* [9.1 数据备份简介](#9_1)
		* [9.1.1 Linux服务器中的哪些数据需要备份](#9_1_1)
		* [9.1.2 备份策略](#9_1_2)
	* [9.2 备份和恢复命令: dump 和 restore ](#9_2)
		* [9.2.1 dump 命令](#9_2_1)
		* [9.2.2 restore 命令](#9_2_2)
	* [9.3 备份命令 dd ](#9_3)

* [第10章 服务器安全一阳指:SELinux管理](#1)
	* [10.1 什么是SELinux](#10_1)
		* [10.1.1 SELinux的作用](#10_1_1)
		* [10.1.2 SELinux的运行模式](#10_1_2)
	* [10.2 SELinux的安装与启动管理](#10_2)
		* [10.2.1 SELinux的安装](#10_2_1)
		* [10.2.2 SELinux的启动管理](#10_2_2)
	* [10.3 SELinux安全上下文管理](#10_3)
		* [10.3.1 安全上下文的查看](#10_3_1)
		* [10.3.2 修改和设置安全上下文](#10_3_2)
		* [10.3.3 查询和修改默认安全上下文](#10_3_3)
	* [10.4 SELinux日志查看](#10_4)
		* [10.4.1 auditd的安装与启动](#10_4_1)
		* [10.4.2 auditd日志的使用](#10_4_2)
	* [10.5 SELinux的策略规则](#10_5)
		* [10.5.1 策略规则的查看](#10_5_1)
		* [10.5.2 策略规则的开启与关闭](#10_5_2)

--------------------------------------------------

## 1
## 第1章 运筹帷幄,操控全盘:高级文件系统管理
 
### 1_1
### 1.1磁盘配额

#### 1_1_1
#### 什么是磁盘配额
    
硬盘配额(Quota)就是Linux系统中用来限制特定的普通用户或用户组在指定的分区上占用的磁盘空间或文件个数的。

第一,root用户不能做硬盘配额；  
第二，硬盘配额限制只能针对分区；   
第三，可以限制用户占用的磁盘容量大小（block),也能限制用户允许占用的文件个数（inode)。   


**前提条件:**

1.  内核必须支持磁盘配额。CentOS6.x版本默认支持。
	> 查看内核配置文件是否支持磁盘配额
	> grep CONFIG_QUOTA /boot/config-2.6.32-279.el6.i686
	
2.  系统中必须安装了Quota工具。
	>rpm -qa|grep quota
	
4.  要支持磁盘配额的分区必须开启磁盘配额功能,这项功能不是默认，需要手工开启。


#### 1_1_2    
#### 磁盘配额中的常见概念

1. 用户配额和组配额

2. 硬盘容量限制和文件个数限制

3. 软限制和硬限制

4. 宽限时间


#### 1_1_3
#### 磁盘配额的实现过程

**开启磁盘配额功能**
    
1.临时开启

```
 mount -o remount,usrquota,grpquota /disk
 #使用临时挂载分区，系统会同步更新/etc/mtab文件
```

2.永久开启

```
 vi /etc/fstab
 /dev/sdb1  /disk  ext4 default,usrquota,grpquota 0 0
 #修改的配置文件如果想要生效,则必须重启系统;否则也需要把分区重新挂载一遍
 mount -o remount /disk
```

**建立磁盘配额配置文件**

配置文件不是手工建立的,而是通过`quotacheck`命令扫描建立的。quotackeck命令会扫描分区,查看分区中每个用户和用户组已经占用的磁盘空间和文件总数,并把扫描结果记录在该分区的最高一级目录下,保存成aquota.user和aquota.group文件.
		
```
 quotacheck [选项] [分区名]
  选项:
	-a:扫描/etc/mtab文件中所有启用磁盘配额功能的分区。如果加入此参数，命令后面就不需要加入分区名了
	-c:不管原有的配置文件，重新扫描并建立新的配置文件
	-u:建立用户配额的配置文件，也应当是生成aquota.user文件
	-g:建立组配额的配置文件，会生成aquota.group文件
	-v:显示扫描过程
	-m:强制以读写的方式扫描文件系统，和-M类似。一般在扫描根分区时使用
	-f:强制扫描文件系统，并写入新的配置文件。一般在扫描新添加的硬盘分区时使用
```

常用的参数就是-avug,而-fm参数一般在文件系统已经启动Quota,如果需要重新扫描分区时使用.

如果命令报错:创建磁盘配额的配置文件时权限不够.这是由于SELinux造成的 vi /etc/selinux/config 修改 SELINUX=enforcing修改为disabled后重启系统

如果我们需要在/分区中建立磁盘配额配置文件，则使用的参数是-avugm,而不是-avug,因为/分区已经被挂载成读写系统，而quotacheck命令需要把分区先挂载成只读分区,然后建立配置文件,最后再挂载回来.所以需要使用-m选项强制以读写方式扫描

**设置用户和组的配额限制**   

当然不能用vi直接编辑aquota.user和aquota.group文件（这两个是二进制文件）而要使用edquota命令进行配置。使用命令进入后就是标准的vi操作方法。

```    
    edquota [选项] [用户名或组名]
    选项:
        -u 用户名：设定用户配额
        -g 组名：设定组配额
        -t 设定宽限时间
        -p 复制配额限制。如果已经设定好某个用户的配额限制，而其他用户的配额限
           制和这个用户相同,那么可以直接复制配额限制,而不用全部手工指定
```


`edquota -u lamp1`

```
    Disk quotas for user lamp1(uid 500):    
    FileSystem  blocks   soft  hard  inodes soft  hard     
    /dev/sdb1   0        0     0     0      0     0    
    #分区名  已占用容量 软限制 硬限制 已占用文件数 软限制 硬限制   
    *文件系统名(分区名):针对哪个分区设定磁盘配额
    *磁盘容量(blocks):当前用户在当前分区中已经占用了多少磁盘空间，单位为KB。这
        项不能修改,是由系统自动检测的.
    *容量软限制(soft):限制用户使用磁盘容量的软限制，单位为KB。
    *容量硬限制(hard):限制用户使用磁盘容量的硬限制，单位为KB。
    *文件数据(inodes):当前用户在当前分区中已经占用的文件数据。这项不能修改，是
        由系统自动检测的.
    *文件个数软限制(soft):限制用户使用文件数据的软限制。
    *文件个数硬限制(hard）：限制用户使用文件个数的硬限制。
    如果限制数是0,则代表没有限制.
```

**配额复制**

```
    edquota -p lamp2 -u lamp3
    #命令 -p 源用户 -u 目标用户
```    

**修改宽限时间**

```    
  edquota -t    		
  Filesystem    Block grace period   Inode grace period    
  /dev/sdb1       8days                8days     
  #分区名       容量的宽限时间       个数的宽限时间    
```

**启动和关闭配额**

```
    配额的配置完成,接下来只需要启动配额就大功告成.
    quotaon [选项] [分区名]
    选项:
        -a:依据/etc/mtab文件启动所有的配额分区。如果不加-a，后面要指定分区名
        -u:启动启用配额
        -g:启动组配额
        -v:显示启动过程的信息
    eg:quotaon -vug /disk/; quotaon -avug
    quotaoff [选项] [分区名]
    选项:
        -a:依据/etc/mtab文件关闭所有的配额分区。如果不加-a，后面要指定分区名
        -u:关闭启用配额
        -g:关闭组配额
    eg: quotaoff -a
```

#### 1_1_4
#### 磁盘配额的查询   

两种查询硬盘配额方法: quota命令查询用户或用户组的配额；repquota命令查询整个分区的配额情况.

```
    quota [选项] [用户名或组名]
    选项:
        -u 用户名：查询用户配额
        -g 组名：查询组配额
        -v : 显示详细信息
        -s : 以习惯单位显示容量大小，如M,G
```

```        

    repquota [选项] [分区名]
    选项:
        -a:依据/etc/mtab文件查询配额。如果不加-a选项，就一定要加分区名
        -u:查询用户配额
        -g:查询组配额
        -v:显示详细信息
        -s:以习惯单位显示容量大小
```


#### 1_1_5
#### 磁盘配额的测试


#### 1_1_6
#### 非交互设定用户磁盘配额

利用setquota 命令进行设置

```    
  setquota -u 用户名 容量软限制 容量硬限制 个数软限制 数据硬限制 分区名
  eg: setquota -u lamp4 10000 20000 5 8 /disk
```    

>[返回目录](#目录)


### 1_2
### LVM(逻辑卷管理)

在以往(2.4内核以前)要想调整分区大小,要么先新建立一个更大的分区,然后复制旧分区中的内容到新分区,最后使用软链接来替代旧分区;要么使用调整分区大小工具(如parted).parted虽然可以调整分区大小，但是它需要卸载分区之后才可以进行，也就是说需要停止服务。而LVM最大的好处就是可以随时调整分区的大小，分区中的现有数据不会丢失，并且不需要卸载分区、停止服务。

#### 1_2_1
#### LVM的概念

**Loggical Volume Manager**的简称，译为中文就是逻辑卷管理。它是Linux系统对磁盘分区的一种管理机制。

LVM是在硬盘分区之上建立一个逻辑层，这个逻辑层让多个硬盘或分区看起来象一块逻辑硬盘,然后将这块逻辑硬盘分成逻辑卷之后使用,从而大大提高了分区的灵活性.我们把真实的物理硬盘或分区称**作物理卷(PV)**;由多个物理卷组成一块大的逻辑硬盘,叫作**卷组(VG)**;将卷组划分成多个可以使用的分区,叫作**逻辑卷(LV)**.而在LVM中最小的存储单位不再是block，而是**物理扩展块（Physical Extend,PE)**.  

在建立LVM的时候，需要按照以下步骤来进行：
> (1) 把物理硬盘分成分区,当然也可以整块物理硬盘.  
> (2) 把物理分区建立为物理卷(PV),也可以直接把整块硬盘都建立为物理卷.  
> (3) 把物理卷整合为卷组(VG).卷组就已经可以动态地调整大小了,可以把物理分区加
 入卷组,也可以把物理分区从卷组中删除.   
> (4) 把卷组再划分为逻辑卷(LV),当然逻辑卷也是可以直接调整大小的.我们说逻辑卷可以想象为分区,所以也需要格式化和挂载.

在安装Linux系统时，采用图形安装界面就可以直接把硬盘配置成LVM（RAID也可以在安装时直接配置）。


#### 1_2_2
#### 图形界面安装系统时配置LVM分区

分区方法选择"创建自定义布局"

注意:引导分区/boot是不能在LVM中划分的，/boot分区必须使用基本分区
一旦配置了LVM,逻辑卷的设备文件名不再是普通分区的命名表示（如/dev/sda1),而是采用“/dev/卷组名/逻辑卷名”的方式命名。

#### 1_2_3
#### 命令模式管理LVM--物理卷管理

**1、硬盘分区**

首先建立所需的物理分区，创建方式就是使用fdisk交互命令。需要**注意**的是，分区的系统ID不再是Linux默认的分区ID **83**，而是改成LVM的ID **8e**。   

```
    eg: fdisk /dev/sdb
        p(查看分区）
        t(改变分区系统ID)
        5(选择哪个分区）
        8e(输入分区ID)
        p(查看分区）
```

用命令partprobe记得重新读取分区表,否则重启系统

**2、建立物理卷** 

建立物理卷的命令:`pvcreate [设备文件名]`   

在建立物理卷时,既可以把整块硬盘都建立成物理卷,也可以把某个分区建立成物理卷. 

如果把整块硬盘都建立成物理卷,命令如下:`pvcreate /dev/sdb`;   

建立某个分区成物理卷命令eg: `pvcreate /dev/sdb5`


**3、查看物理卷**

两个命令:

```    
 pvscan,用来查询系统中哪些硬盘或分区是物理卷   
 pvdisplay,可以查看到更详细的物理卷状态
```

**4、删除物理卷**

`pvremove /dev/sdb7`

在删除物理卷时,物理卷必须不属于任何卷组,也就是需要先将物理卷从卷组中删除,再删除物理卷,其实所有的删除就是把创建过程反过来,建立时不能少某个步骤,删除时也同样不能跳过某一步直接删除.    

#### 1_2_4
#### 命令模式管理LVM--卷组管理

物理分区已经建立,我们也把物理分区建立成了逻辑卷,按照步骤,接下来就要建立卷组了.

我们说可以把卷组想象成基本分区中的硬盘,是由多个物理卷组成的.卷组就已经可以动态地调整空间大小了,当卷组空间不足时,可以向卷组中添加新的物理卷.

1.建立卷组

```
    vgcreate [选项] 卷组名 物理卷名
    选项:
        -s PE大小：指定PE的大小，单位可以是MB，GB,TB等。
           如果不写，则默认4MB     
    eg: vgcreate -s 8MB scvg /dev/sdb5 /dev/sdb6
    #把/dev/sdb5和/dev/sdb6两个物理卷加入了卷组
    #scvg，并指定了PE大小是8MB
```    

2、查看卷组

两个命令:

```    
 vgscan 主要用于查看系统中是否有卷组
 vgdisplay 查看卷组的详细状态
```    

3.增加卷组容量

```    
 vgextend scvg /dev/sdb7
```    

4.减少卷组容量

```    
 vgreduce scvg /dev/sdb7
 vgrecude -a #删除所有未使用的物理卷
```    

5.删除卷组

```
 vgremove scvg
```

只有在删除卷组之后,才能删除物理卷.还要注意的是,scvg卷组中还没有添加任何逻辑卷，如果拥有了逻辑卷，则刻先删除逻辑卷再删除卷组。再次强调，删除就是安装的反过程，每一步不能跳过。


#### 1_2_5
#### 命令模式管理LVM--逻辑卷管理

卷组建立完成后,接下来需要把卷组再划分为逻辑卷.我们可以把逻辑卷想象成分区,那么这个逻辑卷当然也需要被格式化和挂载。另外，逻辑卷也是可以动态调整大小的，而且数据不会丢失，也不用卸载逻辑卷。

1.建立逻辑卷

```    
    lvcreate [选项] [-n 逻辑卷名] 卷组名
    选项:
        -L 容量：指定逻辑卷大小，单位为MB、BG、TB等
        -l 个数：按照PE个数指定逻辑卷大小，这个参数需要换算容量，太麻烦
        -n 逻辑卷名：指定逻辑卷名
```

eg: lvcreate -L 1.5G -n lamplv scvg

#在scvg卷组中建立一个1.5GB大小的lamplv逻辑卷
    
建立完后需要格式化和挂载,设备文件名是"/dev/卷组名/逻辑名"

```    
    mkfs -t ext4 /dev/scvg/lamplv
    mkdir /disklvm
    mount /dev/scvg/lamplv /disklvm
```    

**2.查看逻辑卷**

两个命令:

`lvscan`  `lvdisplay`


**3.调整逻辑卷大小**

可以使用lvresize命令调整逻辑卷大小，不过一般不推荐减少逻辑卷的空间，因为这非常容易导致逻辑卷中的文件系统的数据丢失。所以，除非我们已经备份了逻辑卷中的数据，否则不要减少逻辑卷的空间。

```
    lvresize [选项] 逻辑卷的设备文件名
    选项:
        -L 容量：安装容量调整大小，单位为KB、GB、TB等。使用+代表增加，-代表减少
                 空间.如果直接写容量,则代表设定逻辑卷大小为指定大小.
        -l 个数：按照PE个数调整逻辑卷大小。
```

lamplv逻辑卷大小是1.5GB，而scvg卷组中还有1.5GB的空间空间，那么可以
>    eg: lvresize -L 2.5G /dev/scvg/lamplv
>        lvresize -L +1G /dev/scvg/lamplv
>        lvdisplay

df -h /disklvm/ 查看逻辑卷大小未变，需要使用resize2fs命令调整分区大小，不过不需要卸载分区,直接能调整分区大小.

```
    resize2fs [选项] [设备文件名] [调整的大小]
    选项:
        -f :强制调整
        设备文件名:指定调整哪个分区的大小
        调整的大小:指定分区调整到多大,要加M、G等单位。如果不加大小，则会使用整
                   个分区
    eg: resize2fs /dev/scvg/lamplv
        df -h /disklvm
```

如果要减少逻辑卷的容量,则只需要把增加步骤反过来再做一遍就可以了.

**4.删除逻辑卷**

删除了逻辑卷,其中的数据就会丢失,所以要确定你真的需要删除空上逻辑卷.

`lvremove 逻辑卷的设备文件名`   

我们删除lamplv逻辑卷，刻在删除时要先卸载  

```    
    umount /dev/scvg/lamplv
    lvremove /dev/scvg/lamplv
```

删除逻辑卷后,里面的数据都会被清空

>[返回目录](#目录)


### 1_3
### RAID(磁盘陈列)

LVM最大的优势在于可以在不卸载分区的**不损坏数据**的情况下进行分区容量的调整，但是万一硬盘损坏了，那么数据一定会丢失。RAID（磁盘陈列）的优势在于硬盘读写性能更好，而且具有一定的**数据冗余功能**。

#### 1_3_1
#### RAID简介

RAID(Redundant Arrays of Inexpensive Disks,磁盘阵列），翻译过来就是**廉价的、具有冗余功能的硬盘阵列**。其原理是通过软件或硬件将多块较小的硬盘或分区组合成一个容量较大的磁盘组.这个较大的磁盘组读写性能更好,更重要的是具有数据冗余功能。

 **1. RAID 0**   
 
RAID 0也叫Stripe或Striping(带区卷),是RAID级别中存储性能最好的一个。相当于把一个文件分成几个部分同时向不同的硬盘中写入.

 **2. RAID 1**  
 
RAID 1也叫Mirror或Mirroring(镜象卷),由两块硬盘组成。这种模式是把同一份数据同时写入两块硬盘.

**3. RAID 10 或 RAID 01**

先用两块硬盘组成RAID 1,再用两块硬盘组成另一个RAID 1,最后把这两个RAID 1组成RAID 0,这种RAID方法称作RAID10。  

先组成RAID 0,再组成RAID 1的方法称作RAID 01。

**4. RAID 5**   

RAID 5最少需要由3块硬盘组成，每次循环写入数据的过程中，在其中一块硬盘中加入一个奇偶校验值（Parity)，这个奇偶校验值的内容是这次循环写入时其他硬盘数据的备份。当有一块硬盘损坏时，采用这个奇偶校验值进行数据恢复。

**5. 软RAID和硬RAID**  

实现RAID,可以采用磁盘阵列卡(RAID卡）来组成RAID，也就是硬RAID。RAID卡上有专门的芯片负责RAID任务，因此性能要好得多，而且不占用系统性能，缺点是RAID卡比较昂贵。软RAID是指通过软件实现RAID功能，耗费服务器系统性能，而且数据的写入速度也较硬RAID慢。

#### 1_3_2
#### 图形界面安装系统时配置RAID   

#### 1_3_3
#### 命令模式配置RAID 5   
    
图形界面方便,不过RAID和LVM一样，主要的应用还是在命令行当中，因为如果硬盘出现了数据损坏，总不能重新安装吧！以下举例以最为常见的RAID5

1. 建立三个2GB大小的分区，构建RAID5。不过需要多建立一个2GB大小的分区，用作备份分区,当硬盘或分区损坏时,RAID会自动用备份硬盘或备份分区代替损坏的硬盘或分区,然后立即重建数据,而不需要人为手工参与。
    fdisk -l；/dev/sdb5,/dev/sdb6,/dev/sdb7和、/dev/sdb8这4个分区举例

2. 建立RAID5    

建立RAID使用mdadm命令，格式如下：

```    
    mdadm [模式] [RAID设备文件名] [选项]
    模式:
        Assemble:加入一个已经存在的阵列
        Build:创建一个没有超级块的陈列
        Create:创建一个阵列，每个设备都具有超级块
        Manage:管理阵列，如添加设备和删除损坏设备
        Misc:允许单独对阵列中的设备进行操作，如停止阵列
        Follow or Monitor:监控RAID状态
        Grow:改变RAID的容量或阵列中的数目
    选项:
        -s,--scan:扫描配置文件或/proc/mdstat文件，发现丢失的信息
        -D,--detail:查看磁盘阵列详细信息
        -C,--create:建立新的磁盘阵列，也就是调用Create模式
        -a,--auto=yes:采用标准格式建立磁盘阵列
        -r,--remove 设备文件名：在已经存在的RAID中移除设备
        -f,--fail 设备文件名：把某个组成RAID的设备设置为错误状态
        -S,--stop:停止RAID设备
        -A,--assemble:按照配置文件加载RAID
```

```
    eg: mdadm --create --auto=yes /dev/md0 --level=5 --raid-devices=3 \
        --spare--devices=1 /dev/sdb5 /dev/sdb6 /dev/sdb7 /dev/sdb8
```     

其中,/dev/md0是第一个RAID设备的设备文件名，如果还有RAID设备，则可以使用/dev/md[0-9]来代表。

**查看**: mdadm --detail /dev/md0

/proc/mdstat文件也保存了RAID的相关信息，cat /proc/mdstat

3. 格式化挂载的RAID

```
    mkfs -t ext4 /dev/md0
    mount /dev/md0 /raid/
    mount  #查看
```

4. 生成mdadm配置文件   
  在CentOS 6.x中，mdadm配置文件并不存在，**需要手工建立**。

```
    #建立/etc/mdadm.conf配置文件，并把组成RAID的分区的设备文件写入，注意：如果
    #有多个RAID,则要把所胡组成RAID的设备都放入配置文件中;否则RAID设备重启后会
    #丢失比如组成RAID 10,就即要把分区的设备文件名放入此文件中，也要把组成RAID 0
    #的RAID 1设备文件名放入
    echo Device /dev/sdb[5-8] >>/dev/mdadm.conf

    #查询和扫描RAID信息,并追加进/etc/mdadm.conf文件
    mdadm -Ds >>/dev/mdadm.conf
    cat /etc/mdadm.conf #查看
```

5. 设置开机后自动挂载

```
    vi /etc/fstab
    /dev/md0  /raid   ext4    default    1  2
```
6. 启动或停止RAID   

**停止命令**: `mdadm -S /dev/md0` 

如果要删除RAID,则要把所有和RAID相关的内容全部删除,步骤如下

```    
    umount /dev/md0
    vi /etc/fstab
    /dev/md0  /raid  ext4  defaults 1 2  #删除此行
    mdadm -S /dev/md0
    vi /etc/mdadm.conf
    ARRAY /dev/md0 metadata=1.2 spares=1 ……  #删除或注释此行
```

如果不是删除,仅是停止,只需要先卸载,再停止即可.  

**启动RAID**

```    
        mdadm -As /dev/md0    #启动/dev/md0
        mount /dev/md0 /raid/ #启动后，记得挂载
```

7. 模拟分区出现故障

```
    mdadm -f 作用是把一块硬盘或分区变成错误状态
    mdadm /dev/md0 -f /dev/sdb7
    mdadm -D /dev/md0
```

8. 移除错误分区

```
    mdadm /dev/md0  --remove /dev/sdb7
```

9. 添加新的备份分区

```
    fdisk -l
    mdadm  /dev/md0 --add /dev/sdb9
    mdadm -D /dev/md0
```



>[返回目录](#目录)


--------------------------------------------------

## 2
## 第2章 化简单为神奇：Shell基础

### 2_1
### Shell概述

#### 2_1_1
#### 什么是Shell

    Shell是一个命令解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的
界面系统级程序，用户可以用Shell来启动、挂起、停止甚至编写一些程序.

### 2_2
### Shell脚本的运行方式

### 2_3
### Bash的基本功能

### 2_4
### Bash的变量和运算符

### 2_5
### 环境变更配置文件


>[返回目录](#目录)


--------------------------------------------------

## 3
## 第3章 管理员的九阳神功：Shell编程

### 3_1
### 正则表达式

### 3_2
### 字符截取和替换命令

### 3_3
### 字符处理命令

### 3_4
### 条件判断

### 3_5
### 流程控制



>[返回目录](#目录)


--------------------------------------------------

## 4
## 第4章 庖丁解牛,悬丝诊脉:Linux启动管理

### 4_1
### CentOS 6.x系统启动过程详解

CentOS6.x系统启动过程发生了较大的变化，使用**Upstart启动服务**取代了原先的
SystemV init启动服务。Upstart启动服务的效率更高，启动速度更快。

#### 4_1_1
#### CentOS6.x基本启动流程

(1) 服务器加电，加载BIOS信息，BIOS进行系统检测。依照BIOS设定找到第一个
可以启动的设备(一般是硬盘).   
(2) 读取第一个启动设备MBR(主引导记录),加载MBR中的Boot Loader(启动引导
程序,最为常见的是GRUB).    
(3) 依据Boot Loader的设置加载内核，内核会再进行一遍系统检测。系统一般
会采用内核检测硬件的信息,而不一定采用BIOS的自检信息.内核在检测硬件的同时,还会通过加载动态模块的形式加载硬件的驱动.    
(4) 内核启动系统的第一个进程，也就是/sbin/init   
(5) 由/sbin/init进程调用/etc/init/rcS.conf配置文件，通过这个配置文件
调用/etc/rc.d/rc.sysinit配置文件。而/etc/rc.d/sysinit配置文件是用来进行
系统初始化的,主要用于配置计算机的初始环境.    
(6) 还是通过/etc/init/rcS.conf配置文件调用/etc/inittab配置文件。通过
/etc/inittab配置文件来确定系统的默认运行级别。    
(7) 确定默认运行级别，调用/etc/init/rc.conf配置文件。    
(8) 通过/etc/init/rc.conf配置文件调用并执行/etc/rc.d/rc脚本，并传入
运行级别参数.    
(9) /etc/rc.d/rc确定传入的运行级别，然后运行相应的运行级别目录/etc/rc[0-6].d/中的脚本。    
(10) /etc/rc[0-6].d/目录中的脚本依据设定好的优先级依次启动和关闭。    
(11) 最后执行/etc/rc.d/rc.local中的程序    
(12) 如果是字符界面启动,就可以看到登录界面了.如果图形界面启动,就会
调用相应的X Window接口。    

>[返回目录](#目录)


#### 4_1_2
#### BIOS自检

BIOS(**Basic Input Output System**,基本输入/输出系统) 是固化在主板一个ROM(只读存储器)芯片上的程序，主要保存计算机的基本输入/输出信息、系统设置信息、开机自检程序和系统自启动程序，用来为计算机提供最底层和最直接的硬件设置与控制.
BIOS在系统的启动过程中会加载这些主机信息,并完成第一次系统的自检(第二
次自检由内核完成),我们把BIOS的自检过程称作**POST(Power On Self Test**,加电自检).自检完成之后,开始执行硬件的初始化,之后定义可以启动的设备顺序,然后从第一个可以启动的设备的**MBR(Main Boot Record**,主引导记录)中读取Boot Loader
(启动引导程序).Linux中最常见的Boot Loader 就是GRUB程序。

#### 4_1_3
#### MBR的结构

MBR也就是主引导记录,位于硬盘的0磁道、0柱面、1扇区中，主要记录了启动引导程序的磁盘的分区表.

MBR = 启动引导程序GRUB（446Byte) + 分区表(64Byte) + 结束标记（2Byte)

分区表:

| 第几个字节  | 含义  |
|-----------|-------|
|第1字节     |引导标志   |
|第2字节     |本分区的起始磁道号|
|第3字节     |本分区的起始扇区号|
|第4字节     |本分区的起始柱面号|
|第5字节     |分区类型,可以识别主分区和扩展分区|
|第6字节     |本分区的结束磁道号|
|第7字节     |本分区的结束扇区号|
|第8字节     |本分区的结束柱面号|
|第9~12字节  |本分区之前已经占用的扇区数|
|第13~16字节 |本分区的总扇区数|
    
#### 4_1_4
#### 启动引导程序的作用

BIOS的作用就是自检,然后从MBR中读取出启动引导程序.那么,启动引导程序最主要的作用就是加载操作系统的内核.当然,每种操作系统的启动引导程序都不同.


### 4_2
### 启动引导程序（Boot Loader)

### 4_3
### 内核模块管理

### 4_4
### 系统修复模式


>[返回目录](#目录)


--------------------------------------------------

## 5
## 第5章 掌柜先生敲算盘:服务管理

### 5_1
### 服务的简介与分类

系统服务是后台运行的应用程序,并且可以提供一些本地系统或网络功能.我们把这些应用程序称作服务,也就是service。

Daemon的英文原意是“守护神”，在这里是“守护进程”的意思。守护进程就是
为了实现服务功能的进程.

#### 5_1_1
#### 服务的分类和区分

1. 服务的分类
   >     Linux服务：
   >         RPM包默认安装的服务
   >             独立的服务
   >             基于xinetd的服务
   >         源码包安装的服务

2. 查询已经安装的服务和区分服务

	1. 源码包安装的服务: 不能被服务管理命令直接找到,一般安装到/usr/local/
    2. RPM包默认安装的服务: 会安装到系统默认位置,可以被服务管理命令(如service chkconfig)识别独立的服务 与 基于xinetd的服务 依靠chkconfig命令区分

	>`chkconfig --list [服务名]`
	>
    >        eg:
    >            rpm -ivh xinetd-2.3.14-34.el6.i686.rpm
    >            chkconfig --list
    >                ...
    >                xinetd  0:关闭 1:关闭 2:关闭 3:启用 4:启用 5:启用 6:关闭
    >                ...
    >                基于xinetd的服务：
    >                    chargen-dgram：关闭
    >        xinetd的服务，这些服务没有自己的运行级别，因为它们不是独立的服务，
    >        到底在哪个运行级别可以自启动,则要看xinetd服务是在哪个运行级别自启动的.


>[返回目录](#目录)


#### 5_1_2
#### 服务的端口

**1. 端口简介**  

服务是给系统提供功能的，在系统中除了有系统服务，还有网络服务。而每个网络服务都有自己的端口,一般端口号都是固定的.  

ip地址来确定不同计算机的位置，端口（port）来区分计算机中的网络服务.为了统一整个互联网的端口和网络服务的对应关系,以便以所有的主机都能使用相同的机制来请求或提供服务,同一个服务使用相同的端口,这就是协议.

计算机中的协议主要分为两大类:一类是面向连接的可靠的TCP协议(Transmission Control Protocol,传输控制协议）；另一种是面向无连接的不可靠的UDP协议(User Datagram Protocol,用户数据协议）。这两种协议都支持2的16次方,也就**65535**个端口.    

系统给我们提供了服务与端口的对应文件/etc/services   


**2. 查询系统中已经启动的服务**

判断服务器中开启的服务还有其他方法(如通过ps命令），但是通过端口的方法看最为准确.  

```
    netstat  选项
    选项:
        -a: 列出系统中所有网络连接，包括已经连接的网络服务、监听的网
            络服务和Socket套接字
        -t: 列出TCP数据
        -u: 列出UDP数据
        -l: 列出正在监听的网络服务
        -n: 用端口号来显示服务，而不用服务名
        -p: 列出该服务的进程ID（PID） 
```

执行"netstat -an"我们可以看到Socket套接字，在服务器上，除网络服务可以绑定端口,用端口来接收客户端的请求数据外,系统中的网络程序或我们自己开发的网络程序也可以绑定端口,用端口来接收客户端的请求数据.这些网络程序就是通过Socket套接字来绑定端口。也就是说，网络服务或网络程序要想在网络中传递数据,必须利用Socket套接字绑定端口,并进行数据传递.

Socket套接字虽然不是网络服务，但是同样会占用端口，并在网络中传递数据.Socket套接字的输出如下：

> Proto: 协议，一般是unix    
> RefCnt: 连接到此Socket的进程数量    
> Flags: 连接标识    
> Type: Socket访问类型    
> State: 状态，LISTENING表示监听，CONNECTED表示已经建立连接    
> I-Node: 程序文件的i节点号    
> Path: Socket程序的路径，或者相关数据的输出路径.    

>[返回目录](#目录)

        
### 5_2
### RPM包默认安装的服务管理

RPM包默认安装的服务的一些固定位置：

1.  /etc/init.d/: 此目录软连接到/etc/rc.d/init.d/目录，放置独立服务的启动脚本

2.  /etc/sysconfig/: 放置独立服务的初始化环境配置文件。服务会把自己在初始化过程中的一些参数设置写入这个目录中的文件.

3.  /etc/: 放置服务的配置文件。(注意：源码包安装的服务的配置文件都在自己指定的安装目录中,所以删除源码包时可以直接删除安装目录).

    > /etc/xinetd.conf: 超级守护进程xinetd的配置文件
    > /etc/xinetd.d/：基于xinetd服务的启动脚本。

4.  /var/lib/: 服务如果产生了数据，就会把数据记录在这个目录中。

5.  /var/log: 服务的日志都会放置在这个目录中，如/var/log/httpd/    

可能会有一些特殊文件没有安装到上面位置，如默认安装的apache服务的网页主目录是/var/wwww/html/ 


>[返回目录](#目录)


#### 5_2_1
#### 独立服务的管理

- 独立服务的启动管理

	两种方法:

	1.  /etc/init.d/独立服务名  start|stop|status|restart|...

	2.  使用service命令来启动（service命令实际上只是一个脚本，调用/etc/init.d中的启动脚本来启动独立的服务)

		> service 独立服务 start|stop|restart|...
		> service --status-all  (列出所有独立服务的启动状态)

- 独立服务的自启动管理

	三种方法：

	1. 使用chkconfig管理命令

		> chkconfig --list
		> chkconfig [--level 运行级别] [独立服务名] [on|off]
		> 
		> 	eg:
		> 	chkconfig --level 2345 httpd on

	2. 修改/etc/rc.d/rc.local文件

		> /etc/rc.local 软连接到/etc/rc.d/rc.local,通过加入启动命令达到自启动

	3. 使用ntsysv命令管理自启动

		> netsysv [--level 运行级别] 
		>    
		> 是红帽系统Linux的专有命令，其他的Linux发行版本不一定拥有，他能管理独立服务的自启动，也要以管理xinetd服务的自启动，即只要是RPM安装的即可被管理

- 独立服务的启动脚本分析

	eg: /etc/init.d/httpd

>[返回目录](#目录)


#### 5_2_2
#### 基于xinetd服务的管理

基于xinetd的服务同样有启动管理和自启动管理之分，而不管是启动管理还是自启动管理,都只有一种方法.

1. 基于xinetd服务的启动

	xinetd本身是独立的服务，基于xinetd的服务没有自己独立的启动脚本程序,是需要依赖xinetd的启动脚本来启动。所有基于xinetd这个超级守护进程的其他服务必须改该服务的配置文件,才能启动基于xinetd的服务。配置文件为/etc/xinet.d/目录中 

```
            eg:
            chkconfig --list #也可查看基于xinetd的服务自启动状态
            vim /etc/xinetd.d/telnet
            service xinetd restart
            netstat -tlun|grep 123
```

2. 基于xinetd服务的自启动

	- 使用chkconfig命令管理；chkconfig 服务名 on|off
	
	- 使用ntsysv命令管理；

	> 注意:
	> 
	> 基于xinetd服务的启动和自启动命令之间是通用的，在当前系统中启动了服务,服务的自启动也会开启;关闭了服务的自启动,当前系统中的服务也会关闭.

>[返回目录](#目录)


### 5_3
### 源码包安装的服务管理

#### 5_3_1
#### 源码包服务的启动管理

源码包服务的启动管理方式就是在服务的安装目录中找到管理脚本,然后执行脚本,需要查看每个服务的说明文档(一般是INSTALL或READEM)会有说明启动脚本是哪个。

> eg: /usr/local/apache2/bin/apachectl start|stop|restart|...

#### 5_3_2
#### 源码包服务的自启动管理

把标准启动命令写入/etc/rc.d/rc.local文件中

>[返回目录](#目录)


#### 5_3_3
#### 让源码包服务被服务管理命令识别

在默认情况下,源码包服务是不能被系统的服务管理命令所识别和管理的,但是如果我们做一些设定,则也是可以让源码包服务系统的服务管理依依不舍主所识别和管理.

eg:

```    
        yum -y remove httpd #卸载RPM包默认安装的apache服务
        /usr/local/apache2/bin/apachectl start #启动源码包的apache服务        

        #让源码包安装的apache服务能被service 命令管理启动
        ln -s /usr/local/apache2/bin/apachectl /etc/init.d/apache
        service apache restart

        #让源码包安装的apache服务能被chkconfig命令管理自启动
        vim /etc/init.d/apache
            #!/bin/sh
            #
            # chkconfig: 35 86 76
            #指定httpd脚本可以被chkconfig命令所管理
            #格式是: chkconfig: 运行级别 启动顺序 关闭顺序
            # 让apache服务在3和5级别中能被chkconfig命令所管理，启动顺序是S86, 
            # 关闭顺序是K76(自定顺序，不要和系统中的已有的启动顺序冲突)
            # descripttion: source package apacke
            # 说明,内容随意 以上两句必须加入,才能被chkconfig命令所识别

        chkconfig --add apache #让chkconfig命令能够管理源码包安装的apache服务
        chkconfig --list|grep apache
```

ntsysv命令与chkconfig命令使用同样的管理机制，chkconfig命令能管理则ntsysv已经可以进行源码安装apache服务的自启动管理了。

```
        chkconfig [选项] [服务名]
        选项:
            --add: 把服务加入chkconfig命令的管理中
            --del: 把服务从chkconfig命令的管理中删除
```

>[返回目录](#目录)


### 5_4
### 总结服务管理

无
            

>[返回目录](#目录)


### 5_5
### Linux中常见服务的作用

在生产服务器上,安装完Linux之后有一步重要的工作，就是服务优化，也就是关闭不  需要的服务,只开启需要的服务.因为服务启动得越多,占用的系统资源就越多,而且被攻击的可能性增加.

|服务名|服务描述|
|-----|------|
|acpid | 电源管理接口.如果是笔记本电脑用户,则建议开启,可以监听内核层的相关电源事件|
|anacron|系统的定时任务程序,是cron的一个子系统| 
|alsasound|alsa 声卡驱动|
|atd|指定系统在特定时间执行某个任务,只能执行一次|
|auditd|审核子系统.如果开启了此服务,那么SELinux的审核信息会写入/var/log/audit/audit.log文件；如果不开启，那么审核信息会记录在syslog中(建议开启)|
|autofs|让服务器可以自动挂载网络中其他服务器的共享数据，一般用来自动挂载NFS服务.如果没有NFS服务,则建议关闭|
|avahi-daemon|avahi是zerocronf协议的实现，它可以在没有DNS服务的局域网里发现基于zerocronf协议 的设备和服务|
|bluetooth|蓝牙设备支持.一般不会在服务器上启用蓝牙设备(建议关闭)|
|capi|仅对使用ISND设备的用户有用|
|chargen_dgram|使用UDP协议的chargen server.其主要提供类似远程打字的功能|
|chargen-stream|同上|
|cpuspeed|可以用来调整CPU的频率.当闲置时,可以自动降低CPU频率来节省电量|
|crond|系统的定时任务，一般的Linux服务器都需要定时任务协助系统维护|
|cvs|一个版本控制系统|
|daytime-dgram|使用TCP协议的daytime守护进程，该协议为客户机实现从远程服务器获取日期和时间的功能(建议关闭)|
|daytime-stream|同上|
|dovecot|邮件服务中POP3/IMAP服务的守护进程，主要用来接收信息。|
| echo-dgram|服务器回显客户服务的进程（建议关闭）|
|echo-stram|同上|
|firstboot|系统安装完成后,有一个欢迎界面,需要对系统进行初始设定.既然不是第一次启动了,则建议关闭.|
|gpm|在字符终端(tty1~tty6)中可以使用鼠标复制和粘贴。|
|haldaemon|检测和支持USB设备.如果是服务器则可以关闭,个人机则建议开启.|
|hidd|蓝牙鼠标、键盘等蓝牙设备检测。必须启动bluetooth服务|
|hplip|HP打印机支持，如果没有HP打印机则关闭|
| httpd|apache服务的守护进程。如果需要启动apache,就开启|
|ip6tables|IPv6的防火墙.目前IPv6协议并没胡使用,可以关闭|
|iptables|防火墙功能.Linux中的防火墙是内核支持功能。这是服务器的主要防护手段,必须开启|
|irda|IrDA提供红外线设备（笔记本电脑、PAD'S、手机、计算器等）间的通信支持.建议关闭|
|irqbalance|支持多核,让CPU可以自动分配系统中断(IRQ),提高系统性能.目前服务器多是多核CPU,请开启|
|isdn|使用ISDN设备连接网络.目前主流的联网方式是光纤接入和ADSL,ISDN已经非常少见,请关闭|
|kdump|该服务可以在开机时进行硬件检测,并会调用相关的设置软件.建议关闭,公在需要时开启|
|lvm2-monitor|该服务可以让系统支持LVM逻辑卷组,如果分区采用的是LVM方式,那么应该开启.建议开启|
|mcstrans|SELinux的支持服务,建议开启|
|mdmonitor|该服务用来监测Software RAID或LVM的信息，不是必须服务，建议关闭|
|messagebus|这是Linux的IPC（Interprocess Communication,进程间通信）服务,用来在各个软件中交换信息.|
|microcode_ctl|Intel系列的CPU可以通过这个服务支持额外的微指令集。建议关闭|
|mysqld|MySQL数据库服务器。如果需要就开启|
|named|DNS服务的的守护进程.用来进行域名解析.如果是DNS服务器则开启:否则关闭|
|netfs|该服务用于在系统启动时自动挂载网络中的文件空间,比如NFS Samba等。需要就开启，否则关闭|
|network|提供网络设置功能.通过这个服务来管理网络,建议开启|
|nfs|NFS(Network File System)服务，Linux与Linux之间的文件共享服务.需要就开启,否则关闭|
|nfslock|在Linux中如果使用了NFS服务，那么，为了避免同一个文件被不同的用户同时编辑,所以有空上锁的服务.有NFS时开启,否则关闭|
|ntpd|该服务可能通过互联网自动更新系统时间,使系统时间永远准确.需要则开启,但不是必需服务|
|pcscd|智能卡检测服务,可以关闭|
|portmap|用在远程过程调用(RPC)的服务,如果没有任何RPC服务,则可以关闭.主要是NFS和NIS服务需要|
|psacct|该守护进程支持几个监控进程活动的工具（建议关闭）|
|rdisc |客户端ICMP路由协议(建议关闭)|
|readahead_early|在系统开启的时候，先将某些进程加载入内存整理，可以加快启动速度(建议关闭)|
|readahead_later |同上|
|restorecond|用于给SELinux监测和重新加载正确的文件上下文，如果开启SELinux,则需要开启|
|rpcgssd|与NFS有关的客户端功能，如果没有NFS就关闭|
|rpcidmapd|同上|
|rsync|远程数据备份守护进程|
|rsyslog|日志管理系统|
|sendmail|sendmail邮件服务的守护进程。如果有邮件服务就开启：否则关闭|
|setroubleshoot|该服务用于将SELinux相关信息记录在日志/var/log/message中。建议开启|
|smartd|该服务用于自动检测硬盘状态.建议开启|
|smb|网络服务samba的守护进程。可以让Linux和Windows之间共享数据。如果需要则开启(建议关闭)|
|squid|代理服务的守护进程.如果需要则开启;否则关闭|
|sshd|ssh加密远程登录管理的服务。服务器的远程管理必须使用此服务，不要关闭|
|syslog|日志的守护进程|
|vsftpd|vsftp服务的守护进程。如果需要ftp服务则开启；否则关闭|
|xfs|这是X Window的字体守护进程，为图形界面提供字体服务。如果不启动图形界面，就不用开启|
|xinetd|超级守护进程.如果有依赖xinetd的服务，就必须开启|
|ypbind|为NIS(网络信息系统）客户激活ypbind服务进程（建议关闭）|
|yum-updatesd|yum的在线升级服务（建议关闭）|
    


>[返回目录](#目录)


--------------------------------------------------

## 6
## 第6章 七剑下天山:系统管理

```
6.1 进程管理
6.2 工作管理
6.3 系统资源查看
6.4 系统定时任务
```

### 6_1
### 进程管理

#### 6_1_1
#### 进程简介

#### 6_1_2
#### 进程的查看

**1. ps命令**

这个命令特殊,它的部分选项不能加入"-"，比如命令"ps aux"，因为ps命令的部分选项需要遵守BSD操作系统的格式.

```
    ps aux
    ps -le
    选项:
        a: 显示一个终端的所有进程，除会话引线外
        u: 显示进程的归属用户及内在的使用情况
        x: 显示没有控制终端的进程
        -l:长格式显示。显示更加详细的信息
        -e:显示所有进程，和-A选项的作用一致
```

>[返回目录](#目录)


**2. top命令**

```
    top [选项]
    选项:
        -d 秒数:   指定top命令每隔几秒更新。默认是3秒
        -b:        使用批处理模式输出。一般和"-n"选项使用，用于重定向到文件中
        -n 次数:   指定top命令执行的次数
        -p:        指定PID
        -s:        使top命令在安全模式中运行，避免在交互模式中出现错误
        -u 用户名: 只监听某个用户的进程
    在top命令的交互模式中可以执行的命令:
        ?或h:       显示交互模式的帮助
        P:         按照CPU的使用率排序，默认就是此选项
        M:          按照内容的使用率排序
        N:          按照PID排序
        T:          按照CPU的累积运算时间排序,也就是按照TIME+项排序
        k:          按照PID给予某个进程一个信号.一般用于中止某个进程
        r:          按照PID给某个进程重设优先级(Nice)值
        q:          退出top命令
```

**3. pstree命令**

```
        pstree [选项]
        选项:
            -p: 显示进程的PID
            -u: 显示进程的所属用户
```

>[返回目录](#目录)


#### 6_1_3
#### 进程的管理

```
        kill -l
        常见的进程信号
        1    SIGHUP    该信号让进程立即关闭,然后重新读取配置文件之后重启
        2    SIGINT    程序中止信号
        8    SIGFPE    在发生致命的算术运算错误时发出.
        9    SIGKILL   用来立即结束程序的运行.本信号不能被阻塞 处理和忽略
        14   SIGALRM   时钟定时信号,计算的是实际的时间或时钟时间.
        15   SIGTERM   正常结束进程的信号,kill命令的默认信号。
        18   SIGCONT   该信号可以让暂停的进程恢复执行.本信号不能被阻断
        19   SIGSTOP   该信号可以暂停前台进程,相当于输出Ctrl+Z快捷键。不能阻断
```

**1、kill命令** 

`kill [信号] PID`


**2、killall命令**

```
        kill [选项][信号] 进程名
        选项:
            -i: 交互式，询问是否要杀死某个进程
            -I: 忽略进程名的大小写
```

**3、pkill命令**   

pkill命令和killall命令非常类似，也是按照进程名来杀死进程的，不过pkill命令可以按照终端号来踢出用户.  

```
        pkill [选项] [信号] 进程名
        选项:
            -t 终端号: 按照终端号踢出用户
```

eg: pkill -9 -t pts/1

#### 6_1_4
#### 进程的优先级

`ps -le`

   > PRI(最终值)=RPI(原始值)+NI    
   > 修改NI值时有几个注意事项：    
   >     (1)NI值的范围是-20\~19      
   >     (2)普通用户调整NI值的范围是0\~19，而且只能调整自己的进程    
   >     (3)普通用户只能调高NI值,而不能降低.     
   >     (4)只有root用户才能设定进程NI值为负值，而且可以调整任何用户的进程。    

```
	1 nice命令
		nice [选项] 命令
		选项:
			-n NI值： 给命令赋予NI值
	2 renice命令
		renice [优先级] PID  #修改已经存在进程的NI值的命令
```

>[返回目录](#目录)


### 6_2
### 工作管理

#### 6_2_1
#### 工作管理简介

前台是指当前可以操控和执行命令的空上操作环境;后台是指工作可以自行运行,但是不能直接用Ctrl+C快捷键来中止它，只能使用fg/bg来调用工作
当前的登录终端只能管理当前终端的工作,而不能管理其他登录终端的工作.
放入后台执行的命令不能和前台用户有交互或需要前台输入,否则只能放入后台暂停

#### 6_2_2
#### 如何把命令放入后台

第一种访求是"命令 &",把命令放入后台执行

第二种方法是在命令执行过程按Ctrl+Z快捷键，命令在后台处于暂停状态

>[返回目录](#目录)


#### 6_2_3
#### 后台命令管理

    1. 查看后台的工作
        jobs [-l]
        选项:
            -l: 显示工作的PID
			
    2. 将后台暂停的工作恢复到前台执行
        fg %工作号
        参数:
            %工作号: "%"可以省略，但是注意工作号和PID的区别
			
    3. 把后台暂停的工作恢复到后台执行
        Ctrl+Z快捷方式放入后台的命令，在后台都处于暂停状态，如何让这个后台工作
    继续在后台执行呢?这就需要使用bg命令了。
        bg %工作号
		
    3. 后台命令脱离登录终端运行
        第一种方法是把需要在后台执行的命令加入/etc/rc.local文件
        第二种方法是使用系统定时任务,让系统在指定的时间执行某个后台命令.
        第三种方法是使用nohup命令

        nohup [命令] &

### 6_3
### 系统资源查看

Linux系统除 ps top pstree这三个命令之外，还有一些重要的系统资源查看命令

>[返回目录](#目录)


#### 6_3_1
#### vmstat命令：监控系统资源

vmstat是Linux中的一个综合性能分析工具，可以用来监控CPU使用、进程状态、内存使用、虚拟内存使用、硬盘输入/输出状态等信息。

```
        vmstat [刷新延时 刷新次数]
        eg:
            vmstat 1 3
        procs -------memory------- --swap-- --io-- -system- -----cpu------
        r  b  swpd free buff cache  si so   bi bo   in cs    us sy id wa st 
        procs: 进程信息字段
            -r: 等待运行的进程数，数量越大，系统越繁忙
            -b: 不可被唤醒的进程数量，数量越大，系统越繁忙
        memory: 内存信息字段
            -swpd: 虚拟内存的使用情况，单位为KB。
            -free: 空闲的内存容量，单位为KB。
            -buff: 缓冲的内存容量，单位为KB。
            -cache:缓存的内存容量，单位为KB。
        swap: 交换分区信息字段
            -si: 从磁盘中交换到内存中数据的数量，单位为KB。
            -so: 从内存交换到磁盘中数据的数量,单位为KB。
        io: 硬盘读/写信息字段
            -bi: 从块设备中读入的数据的总量，单位是块。
            -bo: 写到设备的数据的总量，单位是块。
        system: 系统信息字段
            -in: 每秒被中断的进程次数
            -cs: 每秒进行的事件切换次数
        cpu: CPU信息字段
            -us: 非内核进程消耗CPU运算时间的百分比。
            -sy: 内核进程消耗CPU运算时间的百分比。
            -id: 空闲CPU的百分比
            -wa: 等待I/O所消耗的CPU百分比
            -st: 被虚拟机所盗用的CPU百分比。
```

#### 6_3_2
#### dmesg命令：显示开机时的内核检测信息

在系统启动过程中,内核还需要进行一次系统检测,这些内核检测信息会被记录在内存当中.我们一般利用这个命令查看系统的硬件信息.

```
        dmesg
        dmesg|grep CPU
        dmesg|grep eth0
```

>[返回目录](#目录)


#### 6_3_3
#### free命令:查看内存使用状态

free命令可以查看系统内在和swap交换分区的使用情况，其输出和top命令的内存部分非常相似.

 ```   
        free [-b|-k|-m|-g]
        选项：
            -b: 以字节为单位显示
            -k: 以KB为单位显示，默认显示
            -m/g:以 MB/GB为单位显示
 ```   

eg: 

 ```       
            free
                total      used   free   shared buffers cached
        Mem:   625344      219704 405640 0       56852   85276
        -/+ buffers/cache: 77576  547768
        Swap： 524280      0      524280
```

#### 6_3_4
#### 查看CPU信息

cat /proc/cpuinfo

```
        processor        : 0 #逻辑CPU编号
        vendor_id        : GenuineIntel #CPU制造厂商
        cp family        : 6 #产品的系列代号
        model            : 58 #CPU系列代号

        #CPU系列的名字、编号、主频
        model name       : Intel(R) Core(TM) i7-3630QM CPU@2.50GHz
        stepping         : 9 #更新版本
        cpu MHz          :2394.649 #实际主频
        cache size       : 6144KB  #二级缓存
        ......
```    

>[返回目录](#目录)


#### 6_3_5
#### 查看本机登录用户信息

```
        w
        who
        last   (/var/log/wtmp)
        lastlog(/var/log/lastlog)
```    

>[返回目录](#目录)


#### 6_3_6
#### uptime命令

uptime 命令的作用就是显示系统的启动时间和平均负载,也就是top命令的第一行。其实w命令也能看到这行数据，具体愿意使用哪个看个人习惯。

#### 6_3_7
#### 查看系统与内核的相关信息

```
        uname [选项]
        选项:
            -a: 查看系统所有相关信息
            -r: 查看内核版本
            -s: 查看内核名称
```

>[返回目录](#目录)


#### 6_3_8
#### lsof命令：列出进程调用或打开的文件信息

```
        lsof [选项]
        选项:
            -c 字符串:  只列出以字符串开头的进程打开的文件
            +d 目录名:  列出某个目录中所有被进程调用的文件
            -u 用户名:  只列出某个用户的进程打开的文件
            -p pid:     列出某个PID进程打开的文件
```

>[返回目录](#目录)


### 6_4
### 系统定时任务

系统定时任务主要有两种执行方式:

第一种是使用at命令，at命令定义的系统定时任务只能在指定时间执行一次，而不能循环执行;

第二种是使用crontab命令，这个命令设定的系统定时任务比较灵活。

>[返回目录](#目录)


#### 6_4_1
#### at命令：一次性执行定时任务

**1. atd服务管理与访问控制**    

```
            service atd start
            chkconfig atd on
```
			
at命令的访问控制是依靠/etc/at.allow(白名单)和/etc/at.allow(黑名单)这两个文件来实现的,具体规则如下:

1.   如果系统中有/etc/at.allow文件，那么只有写入此文件中的用户可以使用at命令,其他用户不能使用at命令(/etc/at.deny文件会被忽略)

2.   如果系统中没有/etc/at.allow文件，只有/etc/at.deny文件，那么写入黑名单中的用户不能使用at命令，其他用户可以使用at命令。不过这个文件对root用户不生效。

3.   如果系统中这两个文件都不存在，那么只有root用户可以使用at命令。

**2. at命令**

```        
            at [选项] 时间
            选项:
                -m:   当at工作完成后，无论命令是否有输出，都用E-mail通知执行at
                      命令的用户
                -c 工作号: 显示该at工作的实际内容
            时间:
                HH:MM
                HH:MM YYYY-MM-DD
                HH:MM[am|pm] [month] [date]
                HH:MM[am|pm] +[minutes|hours|days|weeks]
```

eg:

```
                at now +x minutes
                at> /root/hello.sh >>/root/hello.log
                at><EOT>  #使用Ctrl+D快捷键保存at任务

                at -C 8
```

at任务一旦使用Ctrl+D快捷键龕上，实际上写入了/var/spool/at/这个目录，这个目录内的文件可以直接被atd服务调用和执行。
        
**3. 其他at管理命令**

```        
            atq  #查询
            atrm [工作号] #删除指定的at任务
```

>[返回目录](#目录)


#### 6_4_2
#### crontab 命令：循环执行定时任务

**1. crond 服务管理与访问控制**

```
            service crond restart
            chkconfig crond on
```

crontab命令和at命令类似，也是通过/etc/cron.allow和/etc/cron.deny文件来限制某些用户是否可以使用crontab命令的。而且原则也非常相似：

1.  如果系统中有/etc/cron.allow文件，那么只有写入此文件中的用户可以使用crontab命令,其他用户不能使用crontab命令(/etc/cron.deny文件会被忽略)

2.  如果系统中没有/etc/cron.allow文件，只有/etc/cron.deny文件，那么写入黑名单中的用户不能使用crontab命令，其他用户可以使用crontab命令。不过这个文件对root用户不生效。

3.  如果系统中这两个文件都不存在，那么只有root用户可以使用crontab命令。

**2. 用户的crontab设置**

只需要用户身份执行 "crotnab -e"命令即可

```            
            crotnab [选项]
            选项:
                -e: 编辑crontab定时任务
                -l: 查询crontab定时任务
                -r: 删除当前用户所有的crotnab定时任务，只想删除一个，则可以使用
                    "crontab -e"
                -u 用户名: 修改或删除其他用户的crontab定时任务。只有root用户可用
```

`crotnab -e`

  >          #* * * * * 执行任务
  >          #分钟(0~59)
  >          #小时(0~23)
  >          #天(1~31)
  >          #月(1~12)
  >          #星期(0~7:0和7都代表星期日)
  >
  >          时间特殊符号:
  >              * 代表任何时间
  >              , 代表不连接时间如 "0 8,12,16 * * * 命令"
  >              - 代表连接的时间范围
  >              */n 代表每隔多久执行一次


**3. crontab的注意事项**

 -   6个选项都不能为空，必须填写。如果不确定，则使用"*"
	
 -   crontab定时任务的最小有效时间是分钟，最大有效时间是月
	
 -   在定义时间时,日期和星期最好不要在一条定时任务中出现.
	
 -   在定时任务中，不管是直接写命令，还是在脚本中写命令，最好使用绝对路径.


**4. 系统的crontab 设置**

crontab -e命令在定义定时任务时，默认用户身份是当前登录用户。而在修改/etc/crontab配置文件时，定时任务的执行身份是可以手工指定的。

第一种方法就是把需要执行的工作写成脚本程序,并赋予执行权限,然后直接
把这个脚本复制到/etc/cron.{daily,weekly,monthly}目录中的任意一个。

第二种方法就是修改/etc/crotnab这个配置文件，加入自己的定时任务，不过需要注意指定脚本的执行者身份.

>[返回目录](#目录)


#### 6_4_3
#### anacron

在这个定时任务的执行时间我们的服务器刚好没有开机,那么这个定时任务就不会执行了。anacron就是用来解决这个问题的。

在CentOS6.x中anacron有一个变化，就是anacron不再是单独的服务，而变成了系统命令。

```    
        anacron [选项] [工作名]
        选项:
            -s: 开始执行anacron工作，依据/etc/anacrontab文件中设定的延迟时间执行
            -n: 立即执行/etc/anacrontab中所有的工作，忽略所有的延迟时间
            -u: 更新/var/spool/anacron/cron.{daily,weekly,monthly}文件中的时间戳
                ，但不执行任何工作
        参数:
            工作名: 依据/etc/anacrontab 文件中定义的工作名
```

vi /etc/anacrotnab

```        
            SHELL=/bin/sh
            PATH=/sbin:/bin:/usr/sbin:/usr/bin
            MAILTO=root
            RANDOM_DELAY=45
            START_HOURS_RANGE=3-22

            1  5  cron.daily     nice run-parts /etc/cron.daily
            7  25  cron.weekly     nice run-parts /etc/cron.weekly
            @monthly  45  cron.monthly     nice run-parts /etc/cron.monthly
            #天数 强制延迟(分)  工作名     实际执行的命令
            #当时间差超过天数时，强制延迟多少分钟之后就执行命令
```

/etc/cron.{daily,weekly,monthly}目录中的脚本在当前Linu中是被anacron调用的,不再依靠cron服务。如果需要进行修改,则只需要修改/etc/anacrontab配置文件即可。
        


>[返回目录](#目录)



--------------------------------------------------

## 7
## 第7章 凡走过必留下痕迹:日志管理

### 7_1
### 日志简介

日志就算是系统的记账本,记账本中按照时间先后排序记录了系统中发生的所有事件.

#### 7_1_1
#### 日志相关服务

在CentOS6.x中，日志服务已经由rsyslogd取代了原先的syslogd。rsyslogd相比syslogd具有一些新特点：

        (1) 基于TCP网络协议传输日志信息
        (2) 更安全的网络传输方式
        (3) 有日志信息的即时分析框架
        (4) 后台数据库
        (5) 在配置文件中可以写简单的逻辑判断
        (6) 与syslog配置文件相兼容

```
        ps aux|grep "rsyslog"|grep -v "grep"
        chkconfig --list|grep rsyslog
```

系统中的绝大多数日志文件是由rsyslogd服务来统一管理的，只要各个进程将信息给予这个服务,它就自动地把日志按照特定的格式记录到不同的日志文件中.

在Linux系统中有一部分日志不是由rsyslogd服务来管理的，比如apache服务，它的日志是由Apache软件自己产生并记录的，并没有调用rsyslogd服务。但是为了便于读取,apache日志文件的格式和系统默认日志的格式是一致的。

>[返回目录](#目录)


#### 7_1_2
#### 系统中常见的日志文件

日志中有些信息非常敏感,所以在Linux中这些日志文件只有root有可以读取的权限

/var/目录用来保存系统动态数据的目录；

/var/log/目录是系统日志文件的保存目录

|目录|目录描述|
|---|-------|
|/var/log/cron|记录与系统定时任务相关的日志|
|/var/log/cups/|记录打印信息的日志|
|/var/log/dmesg|记录了系统在开机时内核自检的信息|
|/var/log/btmp|记录错误登录的日志.这个文件是二进制文件.|
|/var/log/lastlog|记录系统中所有用户最后一次的登录时间的日志.也是二进制|
|/var/log/maillog|记录邮件信息的日志|
|/var/log/message|记录系统重要信息的日志.这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题，首先要检查的应该就是这个文件|
|/var/log/secure|记录验证和授权方面的信息,只要涉及账户和密码的程序都会记录|
|/var/log/wtmp|永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件，这个文件是二进制文件|
|/var/log/utmp|记录当前已经登录的用户的信息.这个文件会随着用户的登录和注销而不断变化,只记录当前登录用户的信息.这个文件不能用vi查看服务日志|
|/var/log/httpd/|RPM包安装的apache服务的默认日志目录|
|/var/log/mail/|RPM包安装的邮件服务的额外日志目录|
|/var/log/samba/|RPM包安装的Samba服务的日志目录|
|/var/log/sssd/|守护进程安全服务目录|


>[返回目录](#目录)


### 7_2
### 日志服务rsyslogd

主要是服务产生的日志文件的格式和服务的配置文件

#### 7_2_1
#### 日志文件的格式

只要是由日志服务rsyslogd记录的日志文件，它们的格式都是一样的。日志文件的格式包含以下4列:

        (1) 事件产生的时间
        (2) 产生事件的服务器的主机名
        (3) 产生事件的服务名或程序名
        (4) 事件的具体信息

#### 7_2_2
#### rsyslogd服务的配置文件

**1. /etc/rsyslog.conf配置的格式**
        
配置文件主要定义服务的名称 日志等级和日志记录位置

eg:

        authpriv.*                      /var/log/secure
        #服务名称[连接符号]日志等级         日志记录位置

- 服务名称

|服务名|描述|
|---|---|
|auth(LOG_AUTH)|安全和认证相关消息（不推荐使用authpriv替代）|
|authpriv(LOG_AUTHPRIV)|安全和认证相关消息（私有的）|
|cron(LOG_CRON) |系统定时任务cront和at产生的日志|
|daemon(LOG_DAEMON) |与各个守护进程相关的日志|
|ftp(LOG_FTP) |ftp守护进程产生的日志|
|kern(LOG_KERN) |内核产生的日志（不是用户进程产生的）|
|local0-local7(LOG_LOCAL0-7) |为本地使用预留的服务|
|lpr(LOG_LPR) |打印产生的日志|
|mail(LOG_MAIL) |邮件收发信息|
|news(LOG_NEWS) |与新闻服务器相关日志|
|syslog(LOG_SYSLOG) |有syslogd服务产生的日志信息（虽然服务名称已经改为rsyslogd,但是很多配置依然没用了syslogd服务的，所以这里并没有修改服务名称)|
|user(LOG_USER)| 用户等级类别的日志信息|
|uucp(LOG_UUCP) |uucp子系统的日志信息。uucp是早期Linux系统进行数据传递的协议,后来也常用在新闻组服务中|


这些日志服务名称是rsyslogd服务自己定义的，并不是实际的Linux的服务。当有服务需要由rsyslogd服务来帮助管理日志时，只需要调用这些服务名称就可以实现日志的委托管理. 这些日志服务名称大家可以使用命令` man 3 syslog` 来查看


- 连接符号

日志服务[连接符号]日志等级         日志记录位置

连接符号可以被识别以下三种:

|符号|代表含义|
|---|---|
|.|代表只要比后面的等级高的（包含该等级）日志都记录。|
|.=|代表只记录所需等级的日志,其他等级的日志都不记录.|
|.!|代表不等于,也就是除该等级的日志外,其他等级的日志都记录.|

- 日志等级

也可以使用"man 3 syslog"命令来查看。

|||
|---|---|
|debug(LOG_DEBUG)|一般的高度信息说明|
|info(LOG_INFO) | 基本的通知信息|
|notice(LOG_NOTICE)| 普通信息，但是有一定的重要性|
|warning(LOG_WARNING)| 警告信息，但是还不会影响到服务或系统的运行|
|err(LOG_ERR) |错误信息，一般达到err等级的信息已经可以影响到服务或系统的运行了|
|crit(LOG_CRIT) |临界状况信息，比err等级还要严重|
|alert(LOG_ALERT)| 警告状态信息，比crit等级还要严重，必须立即采取行动|
|emerg(LOG_EMERG) |疼痛等级信息，系统已经无法使用了|
|*  | 代表所有日志等级。|
        
日志等级还可以被识别为"none"。如果日志等级是none，就说明忽略这个日志服务,该服务的所有日志都不再记录.


- 日志记录位置
        
可以把日志输出到打印机打印,或者输出到远程日志服务器上(当然,远程日志服务器要允许接收才行).日志的记录位置也是固定的.

            日志文件的绝对路径.(如:/var/log/secure)
            系统设备文件.(如/dev/lp0 代表第一台打印机）

转发给远程主机. (514是日志服务默认端口)

                @192.168.0.210:514 UDP协议发送到192.168.0.210的UDP514端口上
                @@192.168.0.210:514 TCP协议发送到192.168.0.210的tcp514端口上

>用户名.如果是root，就会把日志发送给root用户，当然root要在线，否则就收不到日志信息了.发送日志给用户时,可以使用"\*"代表发送给所有在线用户,如"mail.\*\*"就会把mail服务产生的所有级别的日志发送给所有在线用户.如果需要把日志发送给多个在线用户,则用户名之间用","分隔。
忽略或丢弃日志.如果接收日志对象是"~",则代表这个日志不会被记录,而被直接丢弃


>[返回目录](#目录)


**2. /etc/rsyslog.conf配置文件的内容**

vi /etc/rsyslogd.conf

```        
 $ModLoad  imuxsock  #加载imklog模块，为内核登录提供支持

 #加载UDP模块，允许使用UDP的514端口接收采用UDP协议转发的日志
 $ModLoad imudp
 $UDPServerRun 514

 #加载TCP模块,允许使用TCP的514端口接收采用TCP协议转发的日志
 $ModLoad imtcp
 $InPutTCPServerRun 514

 ......
 $IncludeConfig /etc/rsyslog.d/*.conf
 #包含/etc/rsyslog.d/目录中所有的".conf"子配置文件

 kern.*   /dev/console
 #kern服务.所有日志级别  保存在/dev/console
        
 *.info;mail.none;authpriv.none;cron.none   /var/log/messages
 #所有服务.info以上级别的日志保存在/var/log/message日志文件中，mail
 # authpriv cron的日志不记录在/var/log/message日志文件中，因为它们都有
 # 自己的日志文件

 authpriv.*    /var/log/secure
 mail.*  -/var/log/maillog
 # "-" 的含义是日志先在内存中保存，当日志足够多之后，再向文件中保存

 cron.*  /var/log/cron
 *.emerg  *
 #所有日志服务的疼痛等级日志对所有在线用户广播

 uucp,news.crit  /var/log/spooler

 local7.*  /var/log/boot.log

 #*.* @@remote-host:514
```

**3.定义自己的日志**

如果想要定义自己的日志可以在/etc/rsyslog.conf配置文件中按照格式写入即可,但rsyslogd服务只识别前面定义的服务 

        vi /etc/rsyslogd.conf
        *.crit  /var/log/alert.log

        service rsyslog restart


**4. 日志服务器的设置**

服务器端:

```        
            vi /etc/rsyslog.conf
            $ModLoad imtcp
            $InputTCPServerRun 514

            service rsyslog restart
            netstat -tlun|grep 514
 ```   
 
客户端:

 ```       
            vi /etc/rsyslog.conf
            *.*  @@192.168.0.210:514

            service rsyslog restart 
```  

需要注意的是,日志服务是通过主机名来区别不同的服务器的.所以,如果我们配置了日志服务,则需要给所有的服务器分配不同的主机名.

>[返回目录](#目录)


### 7_3
### 日志轮替

logrotate 用来进行日志轮替（也叫日志转储），也就是把旧的日志文件移动并改名，同时创建一个新的空日志文件来记录新日志,当旧日志文件走出保存的范围时就删除

#### 7_3_1
#### 日志文件的命名规则

依靠/etc/logrotate.conf配置文件中的dateext参数

如果配置文件中有"dateext"参数，那么日志会用日期来作为日志文件的后缀，如"secure-20130605“

如果配置文件中没有"dateext"参数，那么日志文件就需要进行改名了。当第一次进行日志轮替时,当前的"secure"日志会自动改名为"secure.1",然后新建"secure"日志，用来保存新的日志；当第二次进行日志轮替时，"secure.1"会自动改名为"secure.2",当前的"secure"日志会自动改名为"secure.1"

>[返回目录](#目录)


#### 7_3_2
#### logrotate配置文件

主要分三部分：

        1 默认配置 
        2 读取/etc/logrotate.d/目录中的日志轮替的子配置文件
        3 对wtmp和btmp日志文件的轮替进行设定

vi /etc/logrotate.conf

```    
 weekly #第周对日志文件进行一次轮替
 rotate 4 #如果进行了5次日志轮替，就会删除第一个备份日志
 create #在日志轮替时，自动创建新的日志文件
 dateext #使用日期作为日志轮替文件的后缀 
 #compress #日志文件压缩，日志会在转储的同时进行压缩

 #以上日志配置为默认配置
 #如果轮替日志配置了独立参数,那么独立参数的优先级更高

 include /etc/logrotate.d

 /var/log/wtmp{
 monthly  #每月对日志文件进行一次轮替

 #建立的新日志文件,权限是0664,所有者root,属组utmp
 create 0664 root utmp 
 minsize 1M #日志文件最小轮替大小为1MB
 rotate 1 #仅保留一个日志备份
 }

 /var/log/btmp{
 missingok #如果日志不存在，则忽略该日志的警告信息
 monthly
 crete 0600 root utmp
 rotate 1
 }
```

logrotate 配置文件的主要参数

|||
|---|---|
|daily|日志的轮替周期是每天|
|weekly|日志的轮替的周期是每周|
|monthly|日志的轮替周期是每月|
|rotate 数字| 保留的日志文件的个数。0指没有备份|
|compress|当进行日志轮替时，对旧的日志进行压缩|
|create mode owner group| 新建立日志，同时指定新日志的权限与所有者、属组|
|mail address|当进行日志轮替时，输出内容通过邮件发送到指定的邮件地址|
|missingok|如果日志不存在，则忽略该日志的警告信息|
|notifempty|如果日志为空文件，则不进行日志轮替|
|minisize 大小 |日志轮替的最小值|
|size  大小|日志只有大于指定大小才进行日志轮替|
|dateext|使用日期作为日志轮替的后缀|
|sharedscripts |在此关键字之后 的脚本只执行一次|
|prerotate/endscript| 在日志轮替之前执行脚本命令|
|postrotate/endscript |在日志轮替之后执行脚本命令|                

eg:

        "/var/log/httpd/access.log" /var/log/httpd/error.log{
            rotate 5
            mail www@my.org
            size 100k
            sharedscripts
            postrotate
                /usr/bin/killall -HUP httpd
            endscript
        }

需要注意的是，如果日志是写入rsyslog服务的配置文件的，那么把新日志加入logrotate后，一定要重启rsyslog服务，否则虽然新日志建立了，但数据还是写入了旧的日志当中.
    

>[返回目录](#目录)


#### 7_3_3
#### 把自己的日志加入日志轮替

第一种方法是直接在/etc/logrotate.conf配置文件中写入日志的轮替策略

第二种方法是在/etc/logrotate.d/目录中新建立日志的轮替文件，在文件中写入正确的轮替策略

eg:

 ```   
    vi /etc/logrotate.d/alter
        /var/log/alter.log{
            weekly
            rotate 6
            sharedscripts
            prerotate
                /usr/bin/chattr -a /var/log/alter.log
            endscript
        sharedscripts
        postrotate
            /bin/kill -HUP $(/bin/cat /var/run/syslogd.pid 2>/dev/null) &>/dev/null
        endscript
        }

    /date/logs/nginx/access/access.log /date/logs/nginx/access/default.log{
        daiyly
        rotate 30
        create
        compress
        sharedscripts
        postrotate
            /bin/kill -HUP $(/bin/cat /var/run/syslogd.pid) &>/dev/null
            /bin/kill -HUP $(/bin/cat /usr/local/nginx/logs/nginx.pid) &>/dev/null
        endscript
    }
```

>[返回目录](#目录)


#### 7_3_4
#### logrotate命令

vi /etc/cron.daily/logrotate

```    
        #!/bin/sh
        /usr/sbin/logrotate /etc/logrotate.conf >/dev/null 2>&1
        EXITVALUE=$?
        if [ $EXITVALUE != 0 ];then
            /usr/bin/logger -t logrotate "ALERT exited abnormally with [$EXITVALUE]"
        fi
        exit 0

    logrotate [选项] 配置文件名
        选项:
            如果此命令没有选项，则会按照配置文件中的条件进行日志轮替
            -v:  显示日志轮替过程。
            -f: 强制进行日志轮替。不管日志轮替的条件是否符合，强制配置文件中所
                有的日志进行轮替
    logrotate -v /etc/logrotate.conf
    logrotate -vf /etc/logrotate.conf
```

>[返回目录](#目录)


### 7_4
### 日志分析工具

```
    yum -y install logwatch
    cp /usr/share/logwatch/default.conf/logwatch.conf /etc/logwatch/conf/logwatch.conf
```    

这个配置文件的内容中绝大多数是注释,把注释去掉,那么这个配置文件 的内容如下:

```
    vi /etc/logwatch/conf/logwatch.conf
        logDir=/var/log
        TmpDir=/var/cache/logwatch
        MailTo=root
        MailFrom=Logwatch
        Print=
        #是否打印。如果选择"yes",那么日志分析会被打印到标准输出，而且不会发送
        #邮件.我们这里不打印,而是给root用户发送邮件
        
        #Save=/tmp/logwatch #如果开启这一项，日志分析不发送邮件，而是保存在文件

        Detail=Low #可识别的有 Low Med High,也可以用数据表示0~10,0代表最不详细
        Service=All #分析和监控所有日志
        Service="-zz-nework" #不监控zz-network服务日志，"-服务名”表示不分析和
                             #监控此服务的日志
        Service="-zz-sys"
        Service="-eximstats"
```

logwatch 一旦安装，就会在/etc/cron.daily/目录中建立"0logwatch"文件


如果要让这个日志分析马上执行,同只需要执行logwatch命令即可

```
    logwatch #马上执行
    mail #查看邮件
```        


>[返回目录](#目录)



--------------------------------------------------

## 8
## 第8章 搭台唱戏:LAMP环境搭建和LNMP环境搭建


8.1 LAMP环境搭建
    8.1.1 LAMP安装准备工作
    8.1.2 LAMP环境安装过程
8.2 LNMP环境搭建
    8.2.1 LNMP安装前的准备工作
    8.2.2 LNMP环境一键安装步骤
小结


>[返回目录](#目录)


--------------------------------------------------

## 9
## 第9章 常在河边走,哪有不湿鞋:备份与恢复

### 9_1
### 数据备份简介

    对个人:多留几个复本
    对企业:还需要异地备份

#### 9_1_1
#### Linux服务器中的哪些数据需要备份

**1. Linux服务器中的重要数据**

        (1) /root/目录
        (2) /home/目录
        (3) /var/spoole/mail/目录
        (4) /etc/目录
        (5) 其他目录: 如 /var/lib/mysql/

**2. 安装服务的数据**

        apache 服务
            /etc/httpd/conf/httpd.conf
            /var/wwww/html
            /var/log/httpd
            /usr/local/apache2/conf/httpd.conf
            /usr/local/apache2/htdocs/
            /usr/local/apache2/logs
        mysql 服务
            /usr/local/mysql/data/
            /var/lib/mysql/

#### 9_1_2
#### 备份策略

        1. 完全备份
        2. 增量备份
        3. 差异备份

### 9_2
### 备份和恢复命令: dump 和 restore

使用tar或cp命令可以实现数据完全备份，Linux系统中准备了专用的备份和恢复命令


>[返回目录](#目录)


#### 9_2_1
#### dump 命令

 `yum -y install dump`

支持0-9共10个备份级别，0指的是完全备份，1-9都是增量备份。只有在备份整块硬盘或分区时才支持1-9的增量备份级别，如果只是备份某个文件只能使用0级别。

```
    dump [选项] 备份之后的文件名 原文件或目录
    选项:
        -level:    就是我们说的0-9共10个备份级别
        -f 文件名: 指定备份之后的文件名
        -u:        备份成功之后，把备份时间记录在/etc/dumpdates文件中
        -v:        显示备份过程中更多的输出信息
        -j:        调用bzlib库压缩备份文件，其实就是把备份文件压缩为.bz2格
                   式，默认压缩等级是2
        -W:        显示允许被dump的分区的备份等级及备份时间
```

**1. 备份分区**

        dump -0uj -f /root/boot.bak.bz2 /boot/
        cat /etc/dumpdates
        dump -1uj -f /root/boot.bak1.bz2 /boot/
        如果使用了-u选项，可以用dump-W命令查询备份时间及备份级别
        dump -W

        实现差异备份：先用0级备份，以后每次都用1级备份

**2.备份文件或目录**

不支持增量备份,不能使用-u选项更新分区的备份时间,当然也不能使用dump -W

        dump -0j -f /root/etc.dump.bz2 /etc/

>[返回目录](#目录)


#### 9_2_2
#### restore 命令

是dump命令的配套命令

```        
    restore [模式选项] [选项]
    模式选项:
       restore命令常用的模式有以下4种，这4种不能混用。
        -C: 比较备份数据和实际数据的变化。如果实际数据中的现有数据发生了变化
            ,那么这个选项能够检测到这个变化。但是如果实际数据中新增了数据，
            那么这个选项是不能检测到变化的.
        -i: 进入交互模式，手工选择需要恢复的文件
        -t: 查看模式，用于查看备份文件中拥有哪些数据
        -r: 还原模式，用于数据还原
    选项:
        -f: 指定备份文件的文件名
```

1. 比较备份数据和实际数据的变化
    >        注:比较原有的数据变化,新增的数据是不会被检测到的.
   
`restore -C -f /root/boot.bak.bz2`

2. 查看模式

查看备份中到底包含什么内容:

`restore -t -f book.bak.bz2` 
            
3. 还原模式

	restore命令的还原模式既可以用于还原整个分区，也可以用于还原文件或目录.命令格式是一样的,不过要注意,如果要还原增量备份的数据,则一定要先还原完全备份的数据

 ```       
	mkdir boot.test
	cd boot.test
	restore -r -f /root/boot.bak.bz2
	restore -r -f /root/boot.bak1.bz2
 ``` 

>[返回目录](#目录)


### 9_3
### 备份命令 dd

dd命令主要用来进行数据备份，并且可以在备份的过程中进行格式转换。其实dd命令可以把数据复制成目标数据,而且不管源数据是文件、分区、磁盘还是光盘，都可以。

```
    dd if="输入文件" -of="输出文件" bs="数据块" count="数量"
    参数:
        if: 定义输入数据的文件，也可以是输入设备
        of: 定义输出数据的文件，也可以是输出设备
        bs: 指定数据块的大小，也就是定义一次性读取或写入多少字节。模式数据块大
            小是512字节
        count: 指定bs的数量
        conv=标志: 依据标志转换文件
            标志有以下这些:
            ascii   由EBCDIC码转换至ASCII码
            ebcdic  由ASCII码转换到EBCDIC码
            ibm     由ASCII码转换至替换的EBCDIC码
            block   将结束字符块里的换行替换成行长的空格
            unblock 将cbs大小的块中尾部的空格替换为一个换行符
            icase   将大写字符转换为小写
            notrunc 不截断输出文件 
            ucase   将小写字符转换为大写
            swab    交换每一对输入数据字节
            noerror 读取数据发生错误后仍然继续
            sync    将每个输入数据块以NUL字符填满至ibs的大小；当配合block或
                    unblock时，会以空格代替NUL字符填充

    eg:
        dd if=/etc/httpd/conf/httpd.conf of=/tmp/httpd.bak
        dd if=/dev/sda1 of=/tmp/boot.bak
        dd if=/tmp/boot.bak of=dev/sda1
```

如果要把分区直接备份成另一个分区，就需要生成一个新的分区，这个分区大小不能比源分区小,只能和源分区大小一致或比它大

```    
	dd if=/dev/sda1 of=/dev/sdb1
	dd if=/dev/sdb1 of=/dev/sda1
```

整盘备份

```        
	dd if=/dev/sda of=/dev/sdb
	dd if=/dev/sda of=/tmp/disk.bak
	dd if=/tmp/disk.bak of=/dev/sdb
```

软盘

```       
	dd if=/dev/fd0 of=/tmp/fd.bak
	dd if=/tmp/fd.bak of=/dev/fd0
```

制作光盘iso镜像

```        
	dd if=/dev/cdrom of=/tmp/cd.iso
	mkdir /mnt/cd
	mount -o loop /tmp/cd.iso /mnt/cd
```

指定大小的文件

```        
	dd if=/dev/zero of=/tmp/testfile bs=1M count=10
	#输入项/dev/zero会向目标文件中不停地写入二进制的0
```

dd命令在进行整盘复制时，类似于GHOST工具的功能，不过通过dd命令复制出来的硬盘要比GHOST复制出来的硬盘数据稳定得多.虽然dd命令功能强大，不过也有一个明显的缺点,就是复制的时间较长,复制100GB的数据需要15~25分钟（根据服务器的性能不同而不同)

实现数据备份还有非常多的方法和工具,比如tar和cpio命令。还有网格复制工具rsync和scp等。



>[返回目录](#目录)


--------------------------------------------------

## 10
## 第10章 服务器安全一阳指:SELinux管理

SELinux是由美国国家安全局（NSA)开发的，整合在Linux内核当中，针对特定的进程与指定的文件资源进行权限控制的系统。

### 10_1
### 什么是SELinux

#### 10_1_1
#### SELinux的作用

   >     SELinux: Security Enhanced Linux
   >     DAC: Discretionary Access Control 传统的自主访问控制()
   >     MAC: Mandatory Access Control SELinux中采用的是强制访问控制


#### 10_1_2
#### SELinux的运行模式

        主体(Subject):就是想要访问文件或目录资源的进程。
        目标(Object):就是需要访问的文件或目录资源.
        策略(Policy):SELinux默认定义了两个策略，规则都已经在这两个策略中写好，
            默认只要调用策略就可以正常使用了.
            (1)targeted: 这是SELinux的默认策略，这个策略主要是限制网络服务的，
                对本机系统的限制极少。我们使用这个策略已经足够了。
            (2)mls: 多级安全保护策略，这个策略限制得更为严格。
        安全上下文(Security Context):每个进程和目录都有自己的安全上下文,进程
            具体是否能够访问文件或目录,就要看这个安全上下文是否匹配。

### 10_2
### SELinux的安装与启动管理

#### 10_2_1
#### 10.2.1 SELinux的安装

在CentOS6.x中，SELinux是整合到Linux的内核当中的，并且是启动的，但是很多的SELinux管理工具需要我们手工安装.

```
	yum -y install setroubleshoot
	yum -y install setools-console
```

#### 10_2_2
#### SELinux的启动管理

```
	vim /etc/selinux/config
        SELINUX=enforcing
            #enforcing 强制模式 代表SELinux已经启动，所有策略已经生效
            #permissive 宽容模式 代表SELinux已经启动，但是只会显示警告信息
            #disabled 不生效 代表SELinux被禁用
        SELINUXTYPE=targeted
            #targeted 针对性保护策略，是默认策略
            #mls 多级安全保护策略

```

enforcing 或 permissive 切换到 disable，或反向操作，需要重启系统

enforcing 与 permissive 之间切换不需要重启系统

启动模式,重启Linux系统的速度会比较慢，那是因为需要重新写入安全上下文信息

命令查询SELinux的运行模式: `getenforce`

```
	命令修改SELinux的运行模式：setenforce 选项
	选项:
		0: 切换成permissive
		1: 切换成enforcing
	注:切换到disable或由disable切换别的状态只能修改配置文件
```

>[返回目录](#目录)


### 10_3
### SELinux安全上下文管理

#### 10_3_1
#### 安全上下文的查看

```
	ls -Z 文件
	ls -Zd 目录
	ps auxZ|grep httpd #查看进程
```

安全上下文看起来比较复杂，它使用":"分隔为4个字段，其实共有5个字段，只是最后一个"类别"字段是可选的,例如:

```    
	system_u:object_r:httpd_sys_content_t:s0:[类别]
	#身份字段:角色:类型:灵敏度:[类别]
```

**SELinux的相关命令一般都是以"se"开头的**.

```
	seInfo [选项]
	选项:
		-u: 列出SELinux中所有身份（user)
		-r: 列出SELinux中所有角色（role)
		-t: 列出SELinux中所有类型（type)
		-b: 列出所有的布尔值(也就是策略中的具体规则名称)
		-x: 显示更多的信息
```

身份字段（user)：用于标识该数据被哪个身份所拥有，相当于权限中的用户身份这个字段并没有特别的作用.常见的身份类型有以下三种:

```                         
	- root：表示安全上下文的身份是root
	- system_u: 表示系统用户身份，其中的"_u"代表user
	- user_u: 表示与一般用户账号相关的身份，其中的"_u"代表user
            user字段只用于标识数据或进程被哪个身份所拥有，一般系统数据的user字
            段就是system_u,而用户数据的user字段就是user_u
```


`seinfo -u` 

角色(role):主要用来表示此数据是进程还是文件或目录。这个字段在实际使用中也不需要修改.常见的角色有以下两种.

```                   
	- object_r: 代表该数据是文件或目录，这里的“_r”代表role
	- system_r: 代表该数据是进程，这里的“_r”代表role
```

`seinfo -r`

类型(type): 类型字段是安全上下文中最重要的字段，进程是否可以访问文件，主要就是看进程的安全上下文类型字段是否和文件的安全上下文类型字段相匹配,如果匹配则可以访问.不过需要注意,类型字段在文件或目录的安全上下文中被称作类型(type),但是在进程的安全上下文中被称作域(domain).也就是说，在主体(Subject)的安全上下文中,这个字段被称为域;在目标(Object)的安全上下文中，这个字段被称作类型.域和类型需要匹配才能正确访问.

 `seinfo -t|more`

我们知道了类型的作用,可是我们怎么知道进程的域和文件的类型是否匹配
呢?这就要查询具体的策略规则了.

我们在SELinux中最常遇到的问题就是里程的域和文件的类型不匹配，所以
我们一定要掌握如何修改类型字段.

灵敏度: 灵敏度一般是用s0、s1、s2来命名的，数字代表灵敏度的分级。数值越大,代表灵敏度越高。

类别: 类别字段不是必须有的，所以我们使用ls和ps命令查询的时候并没有看到类别字段.但可以通过seinfo命令查询

```          
	seinfo -u -x  #查询所有的user字段，并查看详细信息
		……
	range:s0 - s0:c0.c1023 #灵敏度可以识别的类别
		……
```

#### 10_3_2
#### 修改和设置安全上下文

主要是通过两个命令来实现

```        
	chcon [选项] 文件或目录
	选项:
		-R: 递归，当前目录和目录下的所有子文件同时设置
		-t: 修改安全上下文的类型字段,最常用
		-u: 修改安全上下文的身份字段
		-r: 修改安全上下文的角色字段
```

```
	restorecon [选项] 文件或目录
	选项:
		-R: 递归，当前目录和目录下所有的文件同时恢复
		-v: 把恢复过程显示到屏幕上
```

#### 10_3_3
#### 查询和修改默认安全上下文

为了管理的便捷,系统给所有的系统默认文件和目录都已经定义了默认的安全上下文

```    
	semanage fcontext -l  #查询所有的默认安全上下文
	semanage fcontext -a -t httpd_sys_content_t "/www(/.*)?"
		-a: 增加默认安全上下文
		-t: 设定默认安全上下文件的类型
         #这条命令会给/wwww/目录及目录下的所有内容设定默认安全上下文类型是
         #    httpd_sys_content_t
        restorecon -Rv /wwww/
```

>[返回目录](#目录)


### 10_4
### SELinux日志查看

在CentOS6.x中的setroubleshoot服务已经不存在了，被sedispatch和seapplet服务取代了,其中sedispatch已经成为audit子系统的一部分，而seapplet则在图形化的SELinux管理工具的工具栏中。

#### 10_4_1
#### auditd的安装与启动

我们当前可以使用的日志系统只有auditd，当然这个服务是需要安装的，在我们的系统中系统中auditd服务是已经安装的。如果没有安装，则：

```    
	yum -y install auditd
	service auditd start
	chkconfig --list|grep auditd
```

#### 10_4_2
#### auditd日志的使用

auditd会把SELinux的信息都记录在/var/log/auditd/auditd.log中。手工查看这个日志效率会很低,Linux准备了几个工具.

**1. audit2why命令**    

audit2why命令用来分析audit.log日志文件，并分析SELinux为什么会拒绝进程的访问.

 `audit2why <日志文件名>`

**2. audit2allow命令**    

audit2allow命令作用是分析日志，并提供允许的建议规则或拒绝的建议规则

```           
	audit2allow -a /var/log/audit/audit.log
	#选项 -a:指定日志文件名 
```

**3. sealert命令**   

sealert命令是setroubleshoot客户端工具，也就是SELinux信息诊断客户端工具.虽然setroubleshoot服务已经不存在了，但是sealert命令还是可以使用。

```        
	sealert [选项] 日志文件名
	选项:
		-a: 分析指定的日志文件
```           

>[返回目录](#目录)


### 10_5
### SELinux的策略规则

        虽然策略中的规则数量众多，管理较为麻烦，但是我们还是需要学习规则的基本
    管理,主要包括策略规则的查看、策略规则的开启与关闭。

#### 10_5_1
#### 策略规则的查看

SELinux的默认策略是targeted,那么这个策略中到底包含有多少个规则叫？使用seinfo命令即可查询。

`seinfo -b #查询布尔值，也就是查询规则名字`

seinfo命令只能看到所有规则的名称，如果想要知道规则的具体内容，就需要使用sesearch命令

```    
	sesearch [选项] [规则类型] [表达式]
	选项:
		-h: 显示帮助信息
	规则类型:
		--allow: 显示允许的规则
		--neverallow: 显示从不的规则
		--all: 显示所有的规则
	表达式:
		-a 主体类型: 显示和指定主体的类型相关的规则（主体是访问的发起者，这
		   个s是source的意思，也不是源类型）
		-t 目标类型: 显示和指定目标的类型相关的规则（目标是被访问者，这个t
		   是target的意思，也就是目标类型）
		-b 规则名: 显示规则的具体内容（b是bool，也就是布尔值的意思，这里是批规则名）
```

eg:按照规则名称查询规则的具体内容

```        
	seinfo -b |grep httpd
	seinfo --all -b httpd_manage_ipa

	sesearch --all -s httpd_t -t httpd_sys_content_t
	#可以清楚地看到httpd_t域是允许访问和使用httpd_sys_content_t类型
```

>[返回目录](#目录)


#### 10_5_2
#### 策略规则的开启与关闭

我们虽然不用修改规则的具体内容，不过默认情况下并不是所有规则都是开启的，规则的开启与关闭并不困难

getsebool命令查询规则的开启和关闭状态，使用

setsebool命令来修改规则的开启与关闭状态。

```
    getsebool [选项] [规则名]
    选项:
        -a: 列出所有规则的开启状态
```

```
    setseboot [选项] 规则名=[0|1]
    选项:
        -P:    将改变写入配置文件，永久生效
        规则名=0 将该规则关闭
        规则名=1 将该规则开启
```

getsebool -a|grep httpd

setsebool -P httpd_enable_homedirs=1

```
    eg: yum -y install vsftpd
        yum -y install ftp
        useradd user
        passwd user
        service vsftpd start
        ftp 192.168.4.210
        ……

        audit2why < /var/log/audit/audit.log
        ……

        setsebool -P ftp_home_dir 1

        ftp 192.168.4.210
        ……
```

>[返回目录](#目录)

